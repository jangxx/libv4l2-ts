/** copied and slightly adapted from linux/v4l2-controls.h */

import ref from "ref-napi";
import ref_struct from "ref-struct-di";
import ref_union from "ref-union-di";
import ref_array from "ref-array-di";

const constants_native = require("../build/Release/v4l2_constants.node");

const StructType = ref_struct(ref);
const UnionType = ref_union(ref);
const ArrayType = ref_array(ref);

function _BITUL(val: number) {
	return 1 << val;
}

/* Control classes */
export const V4L2_CTRL_CLASS_USER = 0x00980000;	/* Old-style 'user' controls */
export const V4L2_CTRL_CLASS_CODEC = 0x00990000;	/* Stateful codec controls */
export const V4L2_CTRL_CLASS_CAMERA = 0x009a0000;	/* Camera class controls */
export const V4L2_CTRL_CLASS_FM_TX = 0x009b0000;	/* FM Modulator controls */
export const V4L2_CTRL_CLASS_FLASH = 0x009c0000;	/* Camera flash controls */
export const V4L2_CTRL_CLASS_JPEG = 0x009d0000;	/* JPEG-compression controls */
export const V4L2_CTRL_CLASS_IMAGE_SOURCE = 0x009e0000;	/* Image source controls */
export const V4L2_CTRL_CLASS_IMAGE_PROC = 0x009f0000;	/* Image processing controls */
export const V4L2_CTRL_CLASS_DV = 0x00a00000;	/* Digital Video controls */
export const V4L2_CTRL_CLASS_FM_RX = 0x00a10000;	/* FM Receiver controls */
export const V4L2_CTRL_CLASS_RF_TUNER = 0x00a20000;	/* RF tuner controls */
export const V4L2_CTRL_CLASS_DETECT = 0x00a30000;	/* Detection controls */
export const V4L2_CTRL_CLASS_CODEC_STATELESS = 0x00a40000;	/* Stateless codecs controls */
export const V4L2_CTRL_CLASS_COLORIMETRY = 0x00a50000;	/* Colorimetry controls */

/* User-class control IDs */

export const V4L2_CID_BASE = (V4L2_CTRL_CLASS_USER | 0x900);
export const V4L2_CID_USER_BASE = V4L2_CID_BASE;
export const V4L2_CID_USER_CLASS = (V4L2_CTRL_CLASS_USER | 1);
export const V4L2_CID_BRIGHTNESS = (V4L2_CID_BASE+0);
export const V4L2_CID_CONTRAST = (V4L2_CID_BASE+1);
export const V4L2_CID_SATURATION = (V4L2_CID_BASE+2);
export const V4L2_CID_HUE = (V4L2_CID_BASE+3);
export const V4L2_CID_AUDIO_VOLUME = (V4L2_CID_BASE+5);
export const V4L2_CID_AUDIO_BALANCE = (V4L2_CID_BASE+6);
export const V4L2_CID_AUDIO_BASS = (V4L2_CID_BASE+7);
export const V4L2_CID_AUDIO_TREBLE = (V4L2_CID_BASE+8);
export const V4L2_CID_AUDIO_MUTE = (V4L2_CID_BASE+9);
export const V4L2_CID_AUDIO_LOUDNESS = (V4L2_CID_BASE+10);
export const V4L2_CID_BLACK_LEVEL = (V4L2_CID_BASE+11); /* Deprecated */
export const V4L2_CID_AUTO_WHITE_BALANCE = (V4L2_CID_BASE+12);
export const V4L2_CID_DO_WHITE_BALANCE = (V4L2_CID_BASE+13);
export const V4L2_CID_RED_BALANCE = (V4L2_CID_BASE+14);
export const V4L2_CID_BLUE_BALANCE = (V4L2_CID_BASE+15);
export const V4L2_CID_GAMMA = (V4L2_CID_BASE+16);
export const V4L2_CID_WHITENESS = (V4L2_CID_GAMMA); /* Deprecated */
export const V4L2_CID_EXPOSURE = (V4L2_CID_BASE+17);
export const V4L2_CID_AUTOGAIN = (V4L2_CID_BASE+18);
export const V4L2_CID_GAIN = (V4L2_CID_BASE+19);
export const V4L2_CID_HFLIP = (V4L2_CID_BASE+20);
export const V4L2_CID_VFLIP = (V4L2_CID_BASE+21);

export const V4L2_CID_POWER_LINE_FREQUENCY = (V4L2_CID_BASE+24);

export enum v4l2_power_line_frequency {
	V4L2_CID_POWER_LINE_FREQUENCY_DISABLED	= 0,
	V4L2_CID_POWER_LINE_FREQUENCY_50HZ	= 1,
	V4L2_CID_POWER_LINE_FREQUENCY_60HZ	= 2,
	V4L2_CID_POWER_LINE_FREQUENCY_AUTO	= 3,
};

export const V4L2_CID_HUE_AUTO = (V4L2_CID_BASE+25);
export const V4L2_CID_WHITE_BALANCE_TEMPERATURE = (V4L2_CID_BASE+26);
export const V4L2_CID_SHARPNESS = (V4L2_CID_BASE+27);
export const V4L2_CID_BACKLIGHT_COMPENSATION = (V4L2_CID_BASE+28);
export const V4L2_CID_CHROMA_AGC = (V4L2_CID_BASE+29);
export const V4L2_CID_COLOR_KILLER = (V4L2_CID_BASE+30);
export const V4L2_CID_COLORFX = (V4L2_CID_BASE+31);

export enum v4l2_colorfx {
	V4L2_COLORFX_NONE			= 0,
	V4L2_COLORFX_BW				= 1,
	V4L2_COLORFX_SEPIA			= 2,
	V4L2_COLORFX_NEGATIVE			= 3,
	V4L2_COLORFX_EMBOSS			= 4,
	V4L2_COLORFX_SKETCH			= 5,
	V4L2_COLORFX_SKY_BLUE			= 6,
	V4L2_COLORFX_GRASS_GREEN		= 7,
	V4L2_COLORFX_SKIN_WHITEN		= 8,
	V4L2_COLORFX_VIVID			= 9,
	V4L2_COLORFX_AQUA			= 10,
	V4L2_COLORFX_ART_FREEZE			= 11,
	V4L2_COLORFX_SILHOUETTE			= 12,
	V4L2_COLORFX_SOLARIZATION		= 13,
	V4L2_COLORFX_ANTIQUE			= 14,
	V4L2_COLORFX_SET_CBCR			= 15,
};

export const V4L2_CID_AUTOBRIGHTNESS = (V4L2_CID_BASE+32);
export const V4L2_CID_BAND_STOP_FILTER = (V4L2_CID_BASE+33);

export const V4L2_CID_ROTATE = (V4L2_CID_BASE+34);
export const V4L2_CID_BG_COLOR = (V4L2_CID_BASE+35);

export const V4L2_CID_CHROMA_GAIN = (V4L2_CID_BASE+36);

export const V4L2_CID_ILLUMINATORS_1 = (V4L2_CID_BASE+37);
export const V4L2_CID_ILLUMINATORS_2 = (V4L2_CID_BASE+38);

export const V4L2_CID_MIN_BUFFERS_FOR_CAPTURE = (V4L2_CID_BASE+39);
export const V4L2_CID_MIN_BUFFERS_FOR_OUTPUT = (V4L2_CID_BASE+40);

export const V4L2_CID_ALPHA_COMPONENT = (V4L2_CID_BASE+41);
export const V4L2_CID_COLORFX_CBCR = (V4L2_CID_BASE+42);

/* last CID + 1 */
export const V4L2_CID_LASTP1 = (V4L2_CID_BASE+43);

/* USER-class private control IDs */

/* The base for the meye driver controls. See linux/meye.h for the list
 * of controls. We reserve 16 controls for this driver. */
export const V4L2_CID_USER_MEYE_BASE = (V4L2_CID_USER_BASE + 0x1000);

/* The base for the bttv driver controls.
 * We reserve 32 controls for this driver. */
export const V4L2_CID_USER_BTTV_BASE = (V4L2_CID_USER_BASE + 0x1010);


/* The base for the s2255 driver controls.
 * We reserve 16 controls for this driver. */
export const V4L2_CID_USER_S2255_BASE = (V4L2_CID_USER_BASE + 0x1030);

/*
 * The base for the si476x driver controls. See include/media/drv-intf/si476x.h
 * for the list of controls. Total of 16 controls is reserved for this driver
 */
export const V4L2_CID_USER_SI476X_BASE = (V4L2_CID_USER_BASE + 0x1040);

/* The base for the TI VPE driver controls. Total of 16 controls is reserved for
 * this driver */
export const V4L2_CID_USER_TI_VPE_BASE = (V4L2_CID_USER_BASE + 0x1050);

/* The base for the saa7134 driver controls.
 * We reserve 16 controls for this driver. */
export const V4L2_CID_USER_SAA7134_BASE = (V4L2_CID_USER_BASE + 0x1060);

/* The base for the adv7180 driver controls.
 * We reserve 16 controls for this driver. */
export const V4L2_CID_USER_ADV7180_BASE = (V4L2_CID_USER_BASE + 0x1070);

/* The base for the tc358743 driver controls.
 * We reserve 16 controls for this driver. */
export const V4L2_CID_USER_TC358743_BASE = (V4L2_CID_USER_BASE + 0x1080);

/* The base for the max217x driver controls.
 * We reserve 32 controls for this driver
 */
export const V4L2_CID_USER_MAX217X_BASE = (V4L2_CID_USER_BASE + 0x1090);

/* The base for the imx driver controls.
 * We reserve 16 controls for this driver. */
export const V4L2_CID_USER_IMX_BASE = (V4L2_CID_USER_BASE + 0x10b0);

/*
 * The base for the atmel isc driver controls.
 * We reserve 32 controls for this driver.
 */
export const V4L2_CID_USER_ATMEL_ISC_BASE = (V4L2_CID_USER_BASE + 0x10c0);

/*
 * The base for the CODA driver controls.
 * We reserve 16 controls for this driver.
 */
export const V4L2_CID_USER_CODA_BASE = (V4L2_CID_USER_BASE + 0x10e0);
/*
 * The base for MIPI CCS driver controls.
 * We reserve 128 controls for this driver.
 */
export const V4L2_CID_USER_CCS_BASE = (V4L2_CID_USER_BASE + 0x10f0);

/* MPEG-class control IDs */
/* The MPEG controls are applicable to all codec controls
 * and the 'MPEG' part of the define is historical */

export const V4L2_CID_CODEC_BASE = (V4L2_CTRL_CLASS_CODEC | 0x900);
export const V4L2_CID_CODEC_CLASS = (V4L2_CTRL_CLASS_CODEC | 1);

/*  MPEG streams, specific to multiplexed streams */
export const V4L2_CID_MPEG_STREAM_TYPE = (V4L2_CID_CODEC_BASE+0);

export enum v4l2_mpeg_stream_type {
	V4L2_MPEG_STREAM_TYPE_MPEG2_PS   = 0, /* MPEG-2 program stream */
	V4L2_MPEG_STREAM_TYPE_MPEG2_TS   = 1, /* MPEG-2 transport stream */
	V4L2_MPEG_STREAM_TYPE_MPEG1_SS   = 2, /* MPEG-1 system stream */
	V4L2_MPEG_STREAM_TYPE_MPEG2_DVD  = 3, /* MPEG-2 DVD-compatible stream */
	V4L2_MPEG_STREAM_TYPE_MPEG1_VCD  = 4, /* MPEG-1 VCD-compatible stream */
	V4L2_MPEG_STREAM_TYPE_MPEG2_SVCD = 5, /* MPEG-2 SVCD-compatible stream */
};

export const V4L2_CID_MPEG_STREAM_PID_PMT = (V4L2_CID_CODEC_BASE+1);
export const V4L2_CID_MPEG_STREAM_PID_AUDIO = (V4L2_CID_CODEC_BASE+2);
export const V4L2_CID_MPEG_STREAM_PID_VIDEO = (V4L2_CID_CODEC_BASE+3);
export const V4L2_CID_MPEG_STREAM_PID_PCR = (V4L2_CID_CODEC_BASE+4);
export const V4L2_CID_MPEG_STREAM_PES_ID_AUDIO = (V4L2_CID_CODEC_BASE+5);
export const V4L2_CID_MPEG_STREAM_PES_ID_VIDEO = (V4L2_CID_CODEC_BASE+6);
export const V4L2_CID_MPEG_STREAM_VBI_FMT = (V4L2_CID_CODEC_BASE+7);

export enum v4l2_mpeg_stream_vbi_fmt {
	V4L2_MPEG_STREAM_VBI_FMT_NONE = 0,  /* No VBI in the MPEG stream */
	V4L2_MPEG_STREAM_VBI_FMT_IVTV = 1,  /* VBI in private packets, IVTV format */
};

/*  MPEG audio controls specific to multiplexed streams  */
export const V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ = (V4L2_CID_CODEC_BASE+100);
export enum v4l2_mpeg_audio_sampling_freq {
	V4L2_MPEG_AUDIO_SAMPLING_FREQ_44100 = 0,
	V4L2_MPEG_AUDIO_SAMPLING_FREQ_48000 = 1,
	V4L2_MPEG_AUDIO_SAMPLING_FREQ_32000 = 2,
};
export const V4L2_CID_MPEG_AUDIO_ENCODING = (V4L2_CID_CODEC_BASE+101);
export enum v4l2_mpeg_audio_encoding {
	V4L2_MPEG_AUDIO_ENCODING_LAYER_1 = 0,
	V4L2_MPEG_AUDIO_ENCODING_LAYER_2 = 1,
	V4L2_MPEG_AUDIO_ENCODING_LAYER_3 = 2,
	V4L2_MPEG_AUDIO_ENCODING_AAC     = 3,
	V4L2_MPEG_AUDIO_ENCODING_AC3     = 4,
};
export const V4L2_CID_MPEG_AUDIO_L1_BITRATE = (V4L2_CID_CODEC_BASE+102);
export enum v4l2_mpeg_audio_l1_bitrate {
	V4L2_MPEG_AUDIO_L1_BITRATE_32K  = 0,
	V4L2_MPEG_AUDIO_L1_BITRATE_64K  = 1,
	V4L2_MPEG_AUDIO_L1_BITRATE_96K  = 2,
	V4L2_MPEG_AUDIO_L1_BITRATE_128K = 3,
	V4L2_MPEG_AUDIO_L1_BITRATE_160K = 4,
	V4L2_MPEG_AUDIO_L1_BITRATE_192K = 5,
	V4L2_MPEG_AUDIO_L1_BITRATE_224K = 6,
	V4L2_MPEG_AUDIO_L1_BITRATE_256K = 7,
	V4L2_MPEG_AUDIO_L1_BITRATE_288K = 8,
	V4L2_MPEG_AUDIO_L1_BITRATE_320K = 9,
	V4L2_MPEG_AUDIO_L1_BITRATE_352K = 10,
	V4L2_MPEG_AUDIO_L1_BITRATE_384K = 11,
	V4L2_MPEG_AUDIO_L1_BITRATE_416K = 12,
	V4L2_MPEG_AUDIO_L1_BITRATE_448K = 13,
};
export const V4L2_CID_MPEG_AUDIO_L2_BITRATE = (V4L2_CID_CODEC_BASE+103);
export enum v4l2_mpeg_audio_l2_bitrate {
	V4L2_MPEG_AUDIO_L2_BITRATE_32K  = 0,
	V4L2_MPEG_AUDIO_L2_BITRATE_48K  = 1,
	V4L2_MPEG_AUDIO_L2_BITRATE_56K  = 2,
	V4L2_MPEG_AUDIO_L2_BITRATE_64K  = 3,
	V4L2_MPEG_AUDIO_L2_BITRATE_80K  = 4,
	V4L2_MPEG_AUDIO_L2_BITRATE_96K  = 5,
	V4L2_MPEG_AUDIO_L2_BITRATE_112K = 6,
	V4L2_MPEG_AUDIO_L2_BITRATE_128K = 7,
	V4L2_MPEG_AUDIO_L2_BITRATE_160K = 8,
	V4L2_MPEG_AUDIO_L2_BITRATE_192K = 9,
	V4L2_MPEG_AUDIO_L2_BITRATE_224K = 10,
	V4L2_MPEG_AUDIO_L2_BITRATE_256K = 11,
	V4L2_MPEG_AUDIO_L2_BITRATE_320K = 12,
	V4L2_MPEG_AUDIO_L2_BITRATE_384K = 13,
};
export const V4L2_CID_MPEG_AUDIO_L3_BITRATE = (V4L2_CID_CODEC_BASE+104);
export enum v4l2_mpeg_audio_l3_bitrate {
	V4L2_MPEG_AUDIO_L3_BITRATE_32K  = 0,
	V4L2_MPEG_AUDIO_L3_BITRATE_40K  = 1,
	V4L2_MPEG_AUDIO_L3_BITRATE_48K  = 2,
	V4L2_MPEG_AUDIO_L3_BITRATE_56K  = 3,
	V4L2_MPEG_AUDIO_L3_BITRATE_64K  = 4,
	V4L2_MPEG_AUDIO_L3_BITRATE_80K  = 5,
	V4L2_MPEG_AUDIO_L3_BITRATE_96K  = 6,
	V4L2_MPEG_AUDIO_L3_BITRATE_112K = 7,
	V4L2_MPEG_AUDIO_L3_BITRATE_128K = 8,
	V4L2_MPEG_AUDIO_L3_BITRATE_160K = 9,
	V4L2_MPEG_AUDIO_L3_BITRATE_192K = 10,
	V4L2_MPEG_AUDIO_L3_BITRATE_224K = 11,
	V4L2_MPEG_AUDIO_L3_BITRATE_256K = 12,
	V4L2_MPEG_AUDIO_L3_BITRATE_320K = 13,
};
export const V4L2_CID_MPEG_AUDIO_MODE = (V4L2_CID_CODEC_BASE+105);
export enum v4l2_mpeg_audio_mode {
	V4L2_MPEG_AUDIO_MODE_STEREO       = 0,
	V4L2_MPEG_AUDIO_MODE_JOINT_STEREO = 1,
	V4L2_MPEG_AUDIO_MODE_DUAL         = 2,
	V4L2_MPEG_AUDIO_MODE_MONO         = 3,
};
export const V4L2_CID_MPEG_AUDIO_MODE_EXTENSION = (V4L2_CID_CODEC_BASE+106);
export enum v4l2_mpeg_audio_mode_extension {
	V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_4  = 0,
	V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_8  = 1,
	V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_12 = 2,
	V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_16 = 3,
};
export const V4L2_CID_MPEG_AUDIO_EMPHASIS = (V4L2_CID_CODEC_BASE+107);
export enum v4l2_mpeg_audio_emphasis {
	V4L2_MPEG_AUDIO_EMPHASIS_NONE         = 0,
	V4L2_MPEG_AUDIO_EMPHASIS_50_DIV_15_uS = 1,
	V4L2_MPEG_AUDIO_EMPHASIS_CCITT_J17    = 2,
};
export const V4L2_CID_MPEG_AUDIO_CRC = (V4L2_CID_CODEC_BASE+108);
export enum v4l2_mpeg_audio_crc {
	V4L2_MPEG_AUDIO_CRC_NONE  = 0,
	V4L2_MPEG_AUDIO_CRC_CRC16 = 1,
};
export const V4L2_CID_MPEG_AUDIO_MUTE = (V4L2_CID_CODEC_BASE+109);
export const V4L2_CID_MPEG_AUDIO_AAC_BITRATE = (V4L2_CID_CODEC_BASE+110);
export const V4L2_CID_MPEG_AUDIO_AC3_BITRATE = (V4L2_CID_CODEC_BASE+111);
export enum v4l2_mpeg_audio_ac3_bitrate {
	V4L2_MPEG_AUDIO_AC3_BITRATE_32K  = 0,
	V4L2_MPEG_AUDIO_AC3_BITRATE_40K  = 1,
	V4L2_MPEG_AUDIO_AC3_BITRATE_48K  = 2,
	V4L2_MPEG_AUDIO_AC3_BITRATE_56K  = 3,
	V4L2_MPEG_AUDIO_AC3_BITRATE_64K  = 4,
	V4L2_MPEG_AUDIO_AC3_BITRATE_80K  = 5,
	V4L2_MPEG_AUDIO_AC3_BITRATE_96K  = 6,
	V4L2_MPEG_AUDIO_AC3_BITRATE_112K = 7,
	V4L2_MPEG_AUDIO_AC3_BITRATE_128K = 8,
	V4L2_MPEG_AUDIO_AC3_BITRATE_160K = 9,
	V4L2_MPEG_AUDIO_AC3_BITRATE_192K = 10,
	V4L2_MPEG_AUDIO_AC3_BITRATE_224K = 11,
	V4L2_MPEG_AUDIO_AC3_BITRATE_256K = 12,
	V4L2_MPEG_AUDIO_AC3_BITRATE_320K = 13,
	V4L2_MPEG_AUDIO_AC3_BITRATE_384K = 14,
	V4L2_MPEG_AUDIO_AC3_BITRATE_448K = 15,
	V4L2_MPEG_AUDIO_AC3_BITRATE_512K = 16,
	V4L2_MPEG_AUDIO_AC3_BITRATE_576K = 17,
	V4L2_MPEG_AUDIO_AC3_BITRATE_640K = 18,
};
export const V4L2_CID_MPEG_AUDIO_DEC_PLAYBACK = (V4L2_CID_CODEC_BASE+112);
export enum v4l2_mpeg_audio_dec_playback {
	V4L2_MPEG_AUDIO_DEC_PLAYBACK_AUTO	    = 0,
	V4L2_MPEG_AUDIO_DEC_PLAYBACK_STEREO	    = 1,
	V4L2_MPEG_AUDIO_DEC_PLAYBACK_LEFT	    = 2,
	V4L2_MPEG_AUDIO_DEC_PLAYBACK_RIGHT	    = 3,
	V4L2_MPEG_AUDIO_DEC_PLAYBACK_MONO	    = 4,
	V4L2_MPEG_AUDIO_DEC_PLAYBACK_SWAPPED_STEREO = 5,
};
export const V4L2_CID_MPEG_AUDIO_DEC_MULTILINGUAL_PLAYBACK = (V4L2_CID_CODEC_BASE+113);

/*  MPEG video controls specific to multiplexed streams */
export const V4L2_CID_MPEG_VIDEO_ENCODING = (V4L2_CID_CODEC_BASE+200);
export enum v4l2_mpeg_video_encoding {
	V4L2_MPEG_VIDEO_ENCODING_MPEG_1     = 0,
	V4L2_MPEG_VIDEO_ENCODING_MPEG_2     = 1,
	V4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC = 2,
};
export const V4L2_CID_MPEG_VIDEO_ASPECT = (V4L2_CID_CODEC_BASE+201);
export enum v4l2_mpeg_video_aspect {
	V4L2_MPEG_VIDEO_ASPECT_1x1     = 0,
	V4L2_MPEG_VIDEO_ASPECT_4x3     = 1,
	V4L2_MPEG_VIDEO_ASPECT_16x9    = 2,
	V4L2_MPEG_VIDEO_ASPECT_221x100 = 3,
};
export const V4L2_CID_MPEG_VIDEO_B_FRAMES = (V4L2_CID_CODEC_BASE+202);
export const V4L2_CID_MPEG_VIDEO_GOP_SIZE = (V4L2_CID_CODEC_BASE+203);
export const V4L2_CID_MPEG_VIDEO_GOP_CLOSURE = (V4L2_CID_CODEC_BASE+204);
export const V4L2_CID_MPEG_VIDEO_PULLDOWN = (V4L2_CID_CODEC_BASE+205);
export const V4L2_CID_MPEG_VIDEO_BITRATE_MODE = (V4L2_CID_CODEC_BASE+206);
export enum v4l2_mpeg_video_bitrate_mode {
	V4L2_MPEG_VIDEO_BITRATE_MODE_VBR = 0,
	V4L2_MPEG_VIDEO_BITRATE_MODE_CBR = 1,
	V4L2_MPEG_VIDEO_BITRATE_MODE_CQ  = 2,
};
export const V4L2_CID_MPEG_VIDEO_BITRATE = (V4L2_CID_CODEC_BASE+207);
export const V4L2_CID_MPEG_VIDEO_BITRATE_PEAK = (V4L2_CID_CODEC_BASE+208);
export const V4L2_CID_MPEG_VIDEO_TEMPORAL_DECIMATION = (V4L2_CID_CODEC_BASE+209);
export const V4L2_CID_MPEG_VIDEO_MUTE = (V4L2_CID_CODEC_BASE+210);
export const V4L2_CID_MPEG_VIDEO_MUTE_YUV = (V4L2_CID_CODEC_BASE+211);
export const V4L2_CID_MPEG_VIDEO_DECODER_SLICE_INTERFACE = (V4L2_CID_CODEC_BASE+212);
export const V4L2_CID_MPEG_VIDEO_DECODER_MPEG4_DEBLOCK_FILTER = (V4L2_CID_CODEC_BASE+213);
export const V4L2_CID_MPEG_VIDEO_CYCLIC_INTRA_REFRESH_MB = (V4L2_CID_CODEC_BASE+214);
export const V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE = (V4L2_CID_CODEC_BASE+215);
export const V4L2_CID_MPEG_VIDEO_HEADER_MODE = (V4L2_CID_CODEC_BASE+216);
export enum v4l2_mpeg_video_header_mode {
	V4L2_MPEG_VIDEO_HEADER_MODE_SEPARATE			= 0,
	V4L2_MPEG_VIDEO_HEADER_MODE_JOINED_WITH_1ST_FRAME	= 1,

};
export const V4L2_CID_MPEG_VIDEO_MAX_REF_PIC = (V4L2_CID_CODEC_BASE+217);
export const V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE = (V4L2_CID_CODEC_BASE+218);
export const V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_BYTES = (V4L2_CID_CODEC_BASE+219);
export const V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB = (V4L2_CID_CODEC_BASE+220);
export const V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE = (V4L2_CID_CODEC_BASE+221);
export enum v4l2_mpeg_video_multi_slice_mode {
	V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_SINGLE		= 0,
	V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_MB		= 1,
	V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_BYTES	= 2,
	/* Kept for backwards compatibility reasons. Stupid typo... */
	V4L2_MPEG_VIDEO_MULTI_SICE_MODE_MAX_MB		= 1,
	V4L2_MPEG_VIDEO_MULTI_SICE_MODE_MAX_BYTES	= 2,
};
export const V4L2_CID_MPEG_VIDEO_VBV_SIZE = (V4L2_CID_CODEC_BASE+222);
export const V4L2_CID_MPEG_VIDEO_DEC_PTS = (V4L2_CID_CODEC_BASE+223);
export const V4L2_CID_MPEG_VIDEO_DEC_FRAME = (V4L2_CID_CODEC_BASE+224);
export const V4L2_CID_MPEG_VIDEO_VBV_DELAY = (V4L2_CID_CODEC_BASE+225);
export const V4L2_CID_MPEG_VIDEO_REPEAT_SEQ_HEADER = (V4L2_CID_CODEC_BASE+226);
export const V4L2_CID_MPEG_VIDEO_MV_H_SEARCH_RANGE = (V4L2_CID_CODEC_BASE+227);
export const V4L2_CID_MPEG_VIDEO_MV_V_SEARCH_RANGE = (V4L2_CID_CODEC_BASE+228);
export const V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME = (V4L2_CID_CODEC_BASE+229);
export const V4L2_CID_MPEG_VIDEO_BASELAYER_PRIORITY_ID = (V4L2_CID_CODEC_BASE+230);
export const V4L2_CID_MPEG_VIDEO_AU_DELIMITER = (V4L2_CID_CODEC_BASE+231);
export const V4L2_CID_MPEG_VIDEO_LTR_COUNT = (V4L2_CID_CODEC_BASE+232);
export const V4L2_CID_MPEG_VIDEO_FRAME_LTR_INDEX = (V4L2_CID_CODEC_BASE+233);
export const V4L2_CID_MPEG_VIDEO_USE_LTR_FRAMES = (V4L2_CID_CODEC_BASE+234);
export const V4L2_CID_MPEG_VIDEO_DEC_CONCEAL_COLOR = (V4L2_CID_CODEC_BASE+235);
export const V4L2_CID_MPEG_VIDEO_INTRA_REFRESH_PERIOD = (V4L2_CID_CODEC_BASE+236);

/* CIDs for the MPEG-2 Part 2 (H.262) codec */
export const V4L2_CID_MPEG_VIDEO_MPEG2_LEVEL = (V4L2_CID_CODEC_BASE+270);
export enum v4l2_mpeg_video_mpeg2_level {
	V4L2_MPEG_VIDEO_MPEG2_LEVEL_LOW		= 0,
	V4L2_MPEG_VIDEO_MPEG2_LEVEL_MAIN	= 1,
	V4L2_MPEG_VIDEO_MPEG2_LEVEL_HIGH_1440	= 2,
	V4L2_MPEG_VIDEO_MPEG2_LEVEL_HIGH	= 3,
};
export const V4L2_CID_MPEG_VIDEO_MPEG2_PROFILE = (V4L2_CID_CODEC_BASE+271);
export enum v4l2_mpeg_video_mpeg2_profile {
	V4L2_MPEG_VIDEO_MPEG2_PROFILE_SIMPLE				= 0,
	V4L2_MPEG_VIDEO_MPEG2_PROFILE_MAIN				= 1,
	V4L2_MPEG_VIDEO_MPEG2_PROFILE_SNR_SCALABLE			= 2,
	V4L2_MPEG_VIDEO_MPEG2_PROFILE_SPATIALLY_SCALABLE		= 3,
	V4L2_MPEG_VIDEO_MPEG2_PROFILE_HIGH				= 4,
	V4L2_MPEG_VIDEO_MPEG2_PROFILE_MULTIVIEW				= 5,
};

/* CIDs for the FWHT codec as used by the vicodec driver. */
export const V4L2_CID_FWHT_I_FRAME_QP = (V4L2_CID_CODEC_BASE + 290);
export const V4L2_CID_FWHT_P_FRAME_QP = (V4L2_CID_CODEC_BASE + 291);

export const V4L2_CID_MPEG_VIDEO_H263_I_FRAME_QP = (V4L2_CID_CODEC_BASE+300);
export const V4L2_CID_MPEG_VIDEO_H263_P_FRAME_QP = (V4L2_CID_CODEC_BASE+301);
export const V4L2_CID_MPEG_VIDEO_H263_B_FRAME_QP = (V4L2_CID_CODEC_BASE+302);
export const V4L2_CID_MPEG_VIDEO_H263_MIN_QP = (V4L2_CID_CODEC_BASE+303);
export const V4L2_CID_MPEG_VIDEO_H263_MAX_QP = (V4L2_CID_CODEC_BASE+304);
export const V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP = (V4L2_CID_CODEC_BASE+350);
export const V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP = (V4L2_CID_CODEC_BASE+351);
export const V4L2_CID_MPEG_VIDEO_H264_B_FRAME_QP = (V4L2_CID_CODEC_BASE+352);
export const V4L2_CID_MPEG_VIDEO_H264_MIN_QP = (V4L2_CID_CODEC_BASE+353);
export const V4L2_CID_MPEG_VIDEO_H264_MAX_QP = (V4L2_CID_CODEC_BASE+354);
export const V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM = (V4L2_CID_CODEC_BASE+355);
export const V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE = (V4L2_CID_CODEC_BASE+356);
export const V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE = (V4L2_CID_CODEC_BASE+357);
export enum v4l2_mpeg_video_h264_entropy_mode {
	V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CAVLC	= 0,
	V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CABAC	= 1,
};
export const V4L2_CID_MPEG_VIDEO_H264_I_PERIOD = (V4L2_CID_CODEC_BASE+358);
export const V4L2_CID_MPEG_VIDEO_H264_LEVEL = (V4L2_CID_CODEC_BASE+359);
export enum v4l2_mpeg_video_h264_level {
	V4L2_MPEG_VIDEO_H264_LEVEL_1_0	= 0,
	V4L2_MPEG_VIDEO_H264_LEVEL_1B	= 1,
	V4L2_MPEG_VIDEO_H264_LEVEL_1_1	= 2,
	V4L2_MPEG_VIDEO_H264_LEVEL_1_2	= 3,
	V4L2_MPEG_VIDEO_H264_LEVEL_1_3	= 4,
	V4L2_MPEG_VIDEO_H264_LEVEL_2_0	= 5,
	V4L2_MPEG_VIDEO_H264_LEVEL_2_1	= 6,
	V4L2_MPEG_VIDEO_H264_LEVEL_2_2	= 7,
	V4L2_MPEG_VIDEO_H264_LEVEL_3_0	= 8,
	V4L2_MPEG_VIDEO_H264_LEVEL_3_1	= 9,
	V4L2_MPEG_VIDEO_H264_LEVEL_3_2	= 10,
	V4L2_MPEG_VIDEO_H264_LEVEL_4_0	= 11,
	V4L2_MPEG_VIDEO_H264_LEVEL_4_1	= 12,
	V4L2_MPEG_VIDEO_H264_LEVEL_4_2	= 13,
	V4L2_MPEG_VIDEO_H264_LEVEL_5_0	= 14,
	V4L2_MPEG_VIDEO_H264_LEVEL_5_1	= 15,
	V4L2_MPEG_VIDEO_H264_LEVEL_5_2	= 16,
	V4L2_MPEG_VIDEO_H264_LEVEL_6_0	= 17,
	V4L2_MPEG_VIDEO_H264_LEVEL_6_1	= 18,
	V4L2_MPEG_VIDEO_H264_LEVEL_6_2	= 19,
};
export const V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_ALPHA = (V4L2_CID_CODEC_BASE+360);
export const V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_BETA = (V4L2_CID_CODEC_BASE+361);
export const V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE = (V4L2_CID_CODEC_BASE+362);
export enum v4l2_mpeg_video_h264_loop_filter_mode {
	V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_ENABLED				= 0,
	V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_DISABLED				= 1,
	V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_DISABLED_AT_SLICE_BOUNDARY	= 2,
};
export const V4L2_CID_MPEG_VIDEO_H264_PROFILE = (V4L2_CID_CODEC_BASE+363);
export enum v4l2_mpeg_video_h264_profile {
	V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE			= 0,
	V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE	= 1,
	V4L2_MPEG_VIDEO_H264_PROFILE_MAIN			= 2,
	V4L2_MPEG_VIDEO_H264_PROFILE_EXTENDED			= 3,
	V4L2_MPEG_VIDEO_H264_PROFILE_HIGH			= 4,
	V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_10			= 5,
	V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_422			= 6,
	V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_444_PREDICTIVE	= 7,
	V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_10_INTRA		= 8,
	V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_422_INTRA		= 9,
	V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_444_INTRA		= 10,
	V4L2_MPEG_VIDEO_H264_PROFILE_CAVLC_444_INTRA		= 11,
	V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_BASELINE		= 12,
	V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_HIGH		= 13,
	V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_HIGH_INTRA	= 14,
	V4L2_MPEG_VIDEO_H264_PROFILE_STEREO_HIGH		= 15,
	V4L2_MPEG_VIDEO_H264_PROFILE_MULTIVIEW_HIGH		= 16,
	V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_HIGH		= 17,
};
export const V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_HEIGHT = (V4L2_CID_CODEC_BASE+364);
export const V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_WIDTH = (V4L2_CID_CODEC_BASE+365);
export const V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE = (V4L2_CID_CODEC_BASE+366);
export const V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC = (V4L2_CID_CODEC_BASE+367);
export enum v4l2_mpeg_video_h264_vui_sar_idc {
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_UNSPECIFIED	= 0,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_1x1		= 1,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_12x11		= 2,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_10x11		= 3,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_16x11		= 4,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_40x33		= 5,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_24x11		= 6,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_20x11		= 7,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_32x11		= 8,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_80x33		= 9,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_18x11		= 10,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_15x11		= 11,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_64x33		= 12,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_160x99		= 13,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_4x3		= 14,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_3x2		= 15,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_2x1		= 16,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_EXTENDED	= 17,
};
export const V4L2_CID_MPEG_VIDEO_H264_SEI_FRAME_PACKING = (V4L2_CID_CODEC_BASE+368);
export const V4L2_CID_MPEG_VIDEO_H264_SEI_FP_CURRENT_FRAME_0 = (V4L2_CID_CODEC_BASE+369);
export const V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE = (V4L2_CID_CODEC_BASE+370);
export enum v4l2_mpeg_video_h264_sei_fp_arrangement_type {
	V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_CHECKERBOARD	= 0,
	V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_COLUMN		= 1,
	V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_ROW		= 2,
	V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_SIDE_BY_SIDE	= 3,
	V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_TOP_BOTTOM		= 4,
	V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_TEMPORAL		= 5,
};
export const V4L2_CID_MPEG_VIDEO_H264_FMO = (V4L2_CID_CODEC_BASE+371);
export const V4L2_CID_MPEG_VIDEO_H264_FMO_MAP_TYPE = (V4L2_CID_CODEC_BASE+372);
export enum v4l2_mpeg_video_h264_fmo_map_type {
	V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_INTERLEAVED_SLICES		= 0,
	V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_SCATTERED_SLICES		= 1,
	V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_FOREGROUND_WITH_LEFT_OVER	= 2,
	V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_BOX_OUT			= 3,
	V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_RASTER_SCAN			= 4,
	V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_WIPE_SCAN			= 5,
	V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_EXPLICIT			= 6,
};
export const V4L2_CID_MPEG_VIDEO_H264_FMO_SLICE_GROUP = (V4L2_CID_CODEC_BASE+373);
export const V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_DIRECTION = (V4L2_CID_CODEC_BASE+374);
export enum v4l2_mpeg_video_h264_fmo_change_dir {
	V4L2_MPEG_VIDEO_H264_FMO_CHANGE_DIR_RIGHT	= 0,
	V4L2_MPEG_VIDEO_H264_FMO_CHANGE_DIR_LEFT	= 1,
};
export const V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_RATE = (V4L2_CID_CODEC_BASE+375);
export const V4L2_CID_MPEG_VIDEO_H264_FMO_RUN_LENGTH = (V4L2_CID_CODEC_BASE+376);
export const V4L2_CID_MPEG_VIDEO_H264_ASO = (V4L2_CID_CODEC_BASE+377);
export const V4L2_CID_MPEG_VIDEO_H264_ASO_SLICE_ORDER = (V4L2_CID_CODEC_BASE+378);
export const V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING = (V4L2_CID_CODEC_BASE+379);
export const V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_TYPE = (V4L2_CID_CODEC_BASE+380);
export enum v4l2_mpeg_video_h264_hierarchical_coding_type {
	V4L2_MPEG_VIDEO_H264_HIERARCHICAL_CODING_B	= 0,
	V4L2_MPEG_VIDEO_H264_HIERARCHICAL_CODING_P	= 1,
};
export const V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER = (V4L2_CID_CODEC_BASE+381);
export const V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER_QP = (V4L2_CID_CODEC_BASE+382);
export const V4L2_CID_MPEG_VIDEO_H264_CONSTRAINED_INTRA_PREDICTION = (V4L2_CID_CODEC_BASE+383);
export const V4L2_CID_MPEG_VIDEO_H264_CHROMA_QP_INDEX_OFFSET = (V4L2_CID_CODEC_BASE+384);
export const V4L2_CID_MPEG_VIDEO_H264_I_FRAME_MIN_QP = (V4L2_CID_CODEC_BASE+385);
export const V4L2_CID_MPEG_VIDEO_H264_I_FRAME_MAX_QP = (V4L2_CID_CODEC_BASE+386);
export const V4L2_CID_MPEG_VIDEO_H264_P_FRAME_MIN_QP = (V4L2_CID_CODEC_BASE+387);
export const V4L2_CID_MPEG_VIDEO_H264_P_FRAME_MAX_QP = (V4L2_CID_CODEC_BASE+388);
export const V4L2_CID_MPEG_VIDEO_H264_B_FRAME_MIN_QP = (V4L2_CID_CODEC_BASE+389);
export const V4L2_CID_MPEG_VIDEO_H264_B_FRAME_MAX_QP = (V4L2_CID_CODEC_BASE+390);
export const V4L2_CID_MPEG_VIDEO_H264_HIER_CODING_L0_BR = (V4L2_CID_CODEC_BASE+391);
export const V4L2_CID_MPEG_VIDEO_H264_HIER_CODING_L1_BR = (V4L2_CID_CODEC_BASE+392);
export const V4L2_CID_MPEG_VIDEO_H264_HIER_CODING_L2_BR = (V4L2_CID_CODEC_BASE+393);
export const V4L2_CID_MPEG_VIDEO_H264_HIER_CODING_L3_BR = (V4L2_CID_CODEC_BASE+394);
export const V4L2_CID_MPEG_VIDEO_H264_HIER_CODING_L4_BR = (V4L2_CID_CODEC_BASE+395);
export const V4L2_CID_MPEG_VIDEO_H264_HIER_CODING_L5_BR = (V4L2_CID_CODEC_BASE+396);
export const V4L2_CID_MPEG_VIDEO_H264_HIER_CODING_L6_BR = (V4L2_CID_CODEC_BASE+397);
export const V4L2_CID_MPEG_VIDEO_MPEG4_I_FRAME_QP = (V4L2_CID_CODEC_BASE+400);
export const V4L2_CID_MPEG_VIDEO_MPEG4_P_FRAME_QP = (V4L2_CID_CODEC_BASE+401);
export const V4L2_CID_MPEG_VIDEO_MPEG4_B_FRAME_QP = (V4L2_CID_CODEC_BASE+402);
export const V4L2_CID_MPEG_VIDEO_MPEG4_MIN_QP = (V4L2_CID_CODEC_BASE+403);
export const V4L2_CID_MPEG_VIDEO_MPEG4_MAX_QP = (V4L2_CID_CODEC_BASE+404);
export const V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL = (V4L2_CID_CODEC_BASE+405);
export enum v4l2_mpeg_video_mpeg4_level {
	V4L2_MPEG_VIDEO_MPEG4_LEVEL_0	= 0,
	V4L2_MPEG_VIDEO_MPEG4_LEVEL_0B	= 1,
	V4L2_MPEG_VIDEO_MPEG4_LEVEL_1	= 2,
	V4L2_MPEG_VIDEO_MPEG4_LEVEL_2	= 3,
	V4L2_MPEG_VIDEO_MPEG4_LEVEL_3	= 4,
	V4L2_MPEG_VIDEO_MPEG4_LEVEL_3B	= 5,
	V4L2_MPEG_VIDEO_MPEG4_LEVEL_4	= 6,
	V4L2_MPEG_VIDEO_MPEG4_LEVEL_5	= 7,
};
export const V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE = (V4L2_CID_CODEC_BASE+406);
export enum v4l2_mpeg_video_mpeg4_profile {
	V4L2_MPEG_VIDEO_MPEG4_PROFILE_SIMPLE				= 0,
	V4L2_MPEG_VIDEO_MPEG4_PROFILE_ADVANCED_SIMPLE			= 1,
	V4L2_MPEG_VIDEO_MPEG4_PROFILE_CORE				= 2,
	V4L2_MPEG_VIDEO_MPEG4_PROFILE_SIMPLE_SCALABLE			= 3,
	V4L2_MPEG_VIDEO_MPEG4_PROFILE_ADVANCED_CODING_EFFICIENCY	= 4,
};
export const V4L2_CID_MPEG_VIDEO_MPEG4_QPEL = (V4L2_CID_CODEC_BASE+407);

/*  Control IDs for VP8 streams
 *  Although VP8 is not part of MPEG we add these controls to the MPEG class
 *  as that class is already handling other video compression standards
 */
export const V4L2_CID_MPEG_VIDEO_VPX_NUM_PARTITIONS = (V4L2_CID_CODEC_BASE+500);
export enum v4l2_vp8_num_partitions {
	V4L2_CID_MPEG_VIDEO_VPX_1_PARTITION	= 0,
	V4L2_CID_MPEG_VIDEO_VPX_2_PARTITIONS	= 1,
	V4L2_CID_MPEG_VIDEO_VPX_4_PARTITIONS	= 2,
	V4L2_CID_MPEG_VIDEO_VPX_8_PARTITIONS	= 3,
};
export const V4L2_CID_MPEG_VIDEO_VPX_IMD_DISABLE_4X4 = (V4L2_CID_CODEC_BASE+501);
export const V4L2_CID_MPEG_VIDEO_VPX_NUM_REF_FRAMES = (V4L2_CID_CODEC_BASE+502);
export enum v4l2_vp8_num_ref_frames {
	V4L2_CID_MPEG_VIDEO_VPX_1_REF_FRAME	= 0,
	V4L2_CID_MPEG_VIDEO_VPX_2_REF_FRAME	= 1,
	V4L2_CID_MPEG_VIDEO_VPX_3_REF_FRAME	= 2,
};
export const V4L2_CID_MPEG_VIDEO_VPX_FILTER_LEVEL = (V4L2_CID_CODEC_BASE+503);
export const V4L2_CID_MPEG_VIDEO_VPX_FILTER_SHARPNESS = (V4L2_CID_CODEC_BASE+504);
export const V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_REF_PERIOD = (V4L2_CID_CODEC_BASE+505);
export const V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_SEL = (V4L2_CID_CODEC_BASE+506);
export enum v4l2_vp8_golden_frame_sel {
	V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_USE_PREV		= 0,
	V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_USE_REF_PERIOD	= 1,
};
export const V4L2_CID_MPEG_VIDEO_VPX_MIN_QP = (V4L2_CID_CODEC_BASE+507);
export const V4L2_CID_MPEG_VIDEO_VPX_MAX_QP = (V4L2_CID_CODEC_BASE+508);
export const V4L2_CID_MPEG_VIDEO_VPX_I_FRAME_QP = (V4L2_CID_CODEC_BASE+509);
export const V4L2_CID_MPEG_VIDEO_VPX_P_FRAME_QP = (V4L2_CID_CODEC_BASE+510);

export const V4L2_CID_MPEG_VIDEO_VP8_PROFILE = (V4L2_CID_CODEC_BASE+511);
export enum v4l2_mpeg_video_vp8_profile {
	V4L2_MPEG_VIDEO_VP8_PROFILE_0				= 0,
	V4L2_MPEG_VIDEO_VP8_PROFILE_1				= 1,
	V4L2_MPEG_VIDEO_VP8_PROFILE_2				= 2,
	V4L2_MPEG_VIDEO_VP8_PROFILE_3				= 3,
};
/* Deprecated alias for compatibility reasons. */
export const V4L2_CID_MPEG_VIDEO_VPX_PROFILE = V4L2_CID_MPEG_VIDEO_VP8_PROFILE;
export const V4L2_CID_MPEG_VIDEO_VP9_PROFILE = (V4L2_CID_CODEC_BASE+512);
export enum v4l2_mpeg_video_vp9_profile {
	V4L2_MPEG_VIDEO_VP9_PROFILE_0				= 0,
	V4L2_MPEG_VIDEO_VP9_PROFILE_1				= 1,
	V4L2_MPEG_VIDEO_VP9_PROFILE_2				= 2,
	V4L2_MPEG_VIDEO_VP9_PROFILE_3				= 3,
};
export const V4L2_CID_MPEG_VIDEO_VP9_LEVEL = (V4L2_CID_CODEC_BASE+513);
export enum v4l2_mpeg_video_vp9_level {
	V4L2_MPEG_VIDEO_VP9_LEVEL_1_0	= 0,
	V4L2_MPEG_VIDEO_VP9_LEVEL_1_1	= 1,
	V4L2_MPEG_VIDEO_VP9_LEVEL_2_0	= 2,
	V4L2_MPEG_VIDEO_VP9_LEVEL_2_1	= 3,
	V4L2_MPEG_VIDEO_VP9_LEVEL_3_0	= 4,
	V4L2_MPEG_VIDEO_VP9_LEVEL_3_1	= 5,
	V4L2_MPEG_VIDEO_VP9_LEVEL_4_0	= 6,
	V4L2_MPEG_VIDEO_VP9_LEVEL_4_1	= 7,
	V4L2_MPEG_VIDEO_VP9_LEVEL_5_0	= 8,
	V4L2_MPEG_VIDEO_VP9_LEVEL_5_1	= 9,
	V4L2_MPEG_VIDEO_VP9_LEVEL_5_2	= 10,
	V4L2_MPEG_VIDEO_VP9_LEVEL_6_0	= 11,
	V4L2_MPEG_VIDEO_VP9_LEVEL_6_1	= 12,
	V4L2_MPEG_VIDEO_VP9_LEVEL_6_2	= 13,
};

/* CIDs for HEVC encoding. */

export const V4L2_CID_MPEG_VIDEO_HEVC_MIN_QP = (V4L2_CID_CODEC_BASE + 600);
export const V4L2_CID_MPEG_VIDEO_HEVC_MAX_QP = (V4L2_CID_CODEC_BASE + 601);
export const V4L2_CID_MPEG_VIDEO_HEVC_I_FRAME_QP = (V4L2_CID_CODEC_BASE + 602);
export const V4L2_CID_MPEG_VIDEO_HEVC_P_FRAME_QP = (V4L2_CID_CODEC_BASE + 603);
export const V4L2_CID_MPEG_VIDEO_HEVC_B_FRAME_QP = (V4L2_CID_CODEC_BASE + 604);
export const V4L2_CID_MPEG_VIDEO_HEVC_HIER_QP = (V4L2_CID_CODEC_BASE + 605);
export const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_TYPE = (V4L2_CID_CODEC_BASE + 606);
export enum v4l2_mpeg_video_hevc_hier_coding_type {
	V4L2_MPEG_VIDEO_HEVC_HIERARCHICAL_CODING_B	= 0,
	V4L2_MPEG_VIDEO_HEVC_HIERARCHICAL_CODING_P	= 1,
};
export const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_LAYER = (V4L2_CID_CODEC_BASE + 607);
export const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L0_QP = (V4L2_CID_CODEC_BASE + 608);
export const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L1_QP = (V4L2_CID_CODEC_BASE + 609);
export const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L2_QP = (V4L2_CID_CODEC_BASE + 610);
export const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L3_QP = (V4L2_CID_CODEC_BASE + 611);
export const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L4_QP = (V4L2_CID_CODEC_BASE + 612);
export const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L5_QP = (V4L2_CID_CODEC_BASE + 613);
export const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L6_QP = (V4L2_CID_CODEC_BASE + 614);
export const V4L2_CID_MPEG_VIDEO_HEVC_PROFILE = (V4L2_CID_CODEC_BASE + 615);
export enum v4l2_mpeg_video_hevc_profile {
	V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN = 0,
	V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_STILL_PICTURE = 1,
	V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_10 = 2,
};
export const V4L2_CID_MPEG_VIDEO_HEVC_LEVEL = (V4L2_CID_CODEC_BASE + 616);
export enum v4l2_mpeg_video_hevc_level {
	V4L2_MPEG_VIDEO_HEVC_LEVEL_1	= 0,
	V4L2_MPEG_VIDEO_HEVC_LEVEL_2	= 1,
	V4L2_MPEG_VIDEO_HEVC_LEVEL_2_1	= 2,
	V4L2_MPEG_VIDEO_HEVC_LEVEL_3	= 3,
	V4L2_MPEG_VIDEO_HEVC_LEVEL_3_1	= 4,
	V4L2_MPEG_VIDEO_HEVC_LEVEL_4	= 5,
	V4L2_MPEG_VIDEO_HEVC_LEVEL_4_1	= 6,
	V4L2_MPEG_VIDEO_HEVC_LEVEL_5	= 7,
	V4L2_MPEG_VIDEO_HEVC_LEVEL_5_1	= 8,
	V4L2_MPEG_VIDEO_HEVC_LEVEL_5_2	= 9,
	V4L2_MPEG_VIDEO_HEVC_LEVEL_6	= 10,
	V4L2_MPEG_VIDEO_HEVC_LEVEL_6_1	= 11,
	V4L2_MPEG_VIDEO_HEVC_LEVEL_6_2	= 12,
};
export const V4L2_CID_MPEG_VIDEO_HEVC_FRAME_RATE_RESOLUTION = (V4L2_CID_CODEC_BASE + 617);
export const V4L2_CID_MPEG_VIDEO_HEVC_TIER = (V4L2_CID_CODEC_BASE + 618);
export enum v4l2_mpeg_video_hevc_tier {
	V4L2_MPEG_VIDEO_HEVC_TIER_MAIN = 0,
	V4L2_MPEG_VIDEO_HEVC_TIER_HIGH = 1,
};
export const V4L2_CID_MPEG_VIDEO_HEVC_MAX_PARTITION_DEPTH = (V4L2_CID_CODEC_BASE + 619);
export const V4L2_CID_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE = (V4L2_CID_CODEC_BASE + 620);
export enum v4l2_cid_mpeg_video_hevc_loop_filter_mode {
	V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_DISABLED			 = 0,
	V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_ENABLED			 = 1,
	V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_DISABLED_AT_SLICE_BOUNDARY = 2,
};
export const V4L2_CID_MPEG_VIDEO_HEVC_LF_BETA_OFFSET_DIV2 = (V4L2_CID_CODEC_BASE + 621);
export const V4L2_CID_MPEG_VIDEO_HEVC_LF_TC_OFFSET_DIV2 = (V4L2_CID_CODEC_BASE + 622);
export const V4L2_CID_MPEG_VIDEO_HEVC_REFRESH_TYPE = (V4L2_CID_CODEC_BASE + 623);
export enum v4l2_cid_mpeg_video_hevc_refresh_type {
	V4L2_MPEG_VIDEO_HEVC_REFRESH_NONE		= 0,
	V4L2_MPEG_VIDEO_HEVC_REFRESH_CRA		= 1,
	V4L2_MPEG_VIDEO_HEVC_REFRESH_IDR		= 2,
};
export const V4L2_CID_MPEG_VIDEO_HEVC_REFRESH_PERIOD = (V4L2_CID_CODEC_BASE + 624);
export const V4L2_CID_MPEG_VIDEO_HEVC_LOSSLESS_CU = (V4L2_CID_CODEC_BASE + 625);
export const V4L2_CID_MPEG_VIDEO_HEVC_CONST_INTRA_PRED = (V4L2_CID_CODEC_BASE + 626);
export const V4L2_CID_MPEG_VIDEO_HEVC_WAVEFRONT = (V4L2_CID_CODEC_BASE + 627);
export const V4L2_CID_MPEG_VIDEO_HEVC_GENERAL_PB = (V4L2_CID_CODEC_BASE + 628);
export const V4L2_CID_MPEG_VIDEO_HEVC_TEMPORAL_ID = (V4L2_CID_CODEC_BASE + 629);
export const V4L2_CID_MPEG_VIDEO_HEVC_STRONG_SMOOTHING = (V4L2_CID_CODEC_BASE + 630);
export const V4L2_CID_MPEG_VIDEO_HEVC_MAX_NUM_MERGE_MV_MINUS1 = (V4L2_CID_CODEC_BASE + 631);
export const V4L2_CID_MPEG_VIDEO_HEVC_INTRA_PU_SPLIT = (V4L2_CID_CODEC_BASE + 632);
export const V4L2_CID_MPEG_VIDEO_HEVC_TMV_PREDICTION = (V4L2_CID_CODEC_BASE + 633);
export const V4L2_CID_MPEG_VIDEO_HEVC_WITHOUT_STARTCODE = (V4L2_CID_CODEC_BASE + 634);
export const V4L2_CID_MPEG_VIDEO_HEVC_SIZE_OF_LENGTH_FIELD = (V4L2_CID_CODEC_BASE + 635);
export enum v4l2_cid_mpeg_video_hevc_size_of_length_field {
	V4L2_MPEG_VIDEO_HEVC_SIZE_0		= 0,
	V4L2_MPEG_VIDEO_HEVC_SIZE_1		= 1,
	V4L2_MPEG_VIDEO_HEVC_SIZE_2		= 2,
	V4L2_MPEG_VIDEO_HEVC_SIZE_4		= 3,
};
export const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L0_BR = (V4L2_CID_CODEC_BASE + 636);
export const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L1_BR = (V4L2_CID_CODEC_BASE + 637);
export const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L2_BR = (V4L2_CID_CODEC_BASE + 638);
export const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L3_BR = (V4L2_CID_CODEC_BASE + 639);
export const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L4_BR = (V4L2_CID_CODEC_BASE + 640);
export const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L5_BR = (V4L2_CID_CODEC_BASE + 641);
export const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L6_BR = (V4L2_CID_CODEC_BASE + 642);
export const V4L2_CID_MPEG_VIDEO_REF_NUMBER_FOR_PFRAMES = (V4L2_CID_CODEC_BASE + 643);
export const V4L2_CID_MPEG_VIDEO_PREPEND_SPSPPS_TO_IDR = (V4L2_CID_CODEC_BASE + 644);
export const V4L2_CID_MPEG_VIDEO_CONSTANT_QUALITY = (V4L2_CID_CODEC_BASE + 645);
export const V4L2_CID_MPEG_VIDEO_FRAME_SKIP_MODE = (V4L2_CID_CODEC_BASE + 646);
export enum v4l2_mpeg_video_frame_skip_mode {
	V4L2_MPEG_VIDEO_FRAME_SKIP_MODE_DISABLED	= 0,
	V4L2_MPEG_VIDEO_FRAME_SKIP_MODE_LEVEL_LIMIT	= 1,
	V4L2_MPEG_VIDEO_FRAME_SKIP_MODE_BUF_LIMIT	= 2,
};

export const V4L2_CID_MPEG_VIDEO_HEVC_I_FRAME_MIN_QP = (V4L2_CID_CODEC_BASE + 647);
export const V4L2_CID_MPEG_VIDEO_HEVC_I_FRAME_MAX_QP = (V4L2_CID_CODEC_BASE + 648);
export const V4L2_CID_MPEG_VIDEO_HEVC_P_FRAME_MIN_QP = (V4L2_CID_CODEC_BASE + 649);
export const V4L2_CID_MPEG_VIDEO_HEVC_P_FRAME_MAX_QP = (V4L2_CID_CODEC_BASE + 650);
export const V4L2_CID_MPEG_VIDEO_HEVC_B_FRAME_MIN_QP = (V4L2_CID_CODEC_BASE + 651);
export const V4L2_CID_MPEG_VIDEO_HEVC_B_FRAME_MAX_QP = (V4L2_CID_CODEC_BASE + 652);

export const V4L2_CID_MPEG_VIDEO_DEC_DISPLAY_DELAY = (V4L2_CID_CODEC_BASE + 653);
export const V4L2_CID_MPEG_VIDEO_DEC_DISPLAY_DELAY_ENABLE = (V4L2_CID_CODEC_BASE + 654);

/*  MPEG-class control IDs specific to the CX2341x driver as defined by V4L2 */
export const V4L2_CID_CODEC_CX2341X_BASE = (V4L2_CTRL_CLASS_CODEC | 0x1000);
export const V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE = (V4L2_CID_CODEC_CX2341X_BASE+0);
export enum v4l2_mpeg_cx2341x_video_spatial_filter_mode {
	V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_MANUAL = 0,
	V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_AUTO   = 1,
};
export const V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER = (V4L2_CID_CODEC_CX2341X_BASE+1);
export const V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE = (V4L2_CID_CODEC_CX2341X_BASE+2);
export enum v4l2_mpeg_cx2341x_video_luma_spatial_filter_type {
	V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_OFF                  = 0,
	V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_HOR               = 1,
	V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_VERT              = 2,
	V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_HV_SEPARABLE      = 3,
	V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_SYM_NON_SEPARABLE = 4,
};
export const V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE = (V4L2_CID_CODEC_CX2341X_BASE+3);
export enum v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type {
	V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_OFF    = 0,
	V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_1D_HOR = 1,
};
export const V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE = (V4L2_CID_CODEC_CX2341X_BASE+4);
export enum v4l2_mpeg_cx2341x_video_temporal_filter_mode {
	V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_MANUAL = 0,
	V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_AUTO   = 1,
};
export const V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER = (V4L2_CID_CODEC_CX2341X_BASE+5);
export const V4L2_CID_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE = (V4L2_CID_CODEC_CX2341X_BASE+6);
export enum v4l2_mpeg_cx2341x_video_median_filter_type {
	V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_OFF      = 0,
	V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR      = 1,
	V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_VERT     = 2,
	V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR_VERT = 3,
	V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_DIAG     = 4,
};
export const V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_BOTTOM = (V4L2_CID_CODEC_CX2341X_BASE+7);
export const V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_TOP = (V4L2_CID_CODEC_CX2341X_BASE+8);
export const V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_BOTTOM = (V4L2_CID_CODEC_CX2341X_BASE+9);
export const V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_TOP = (V4L2_CID_CODEC_CX2341X_BASE+10);
export const V4L2_CID_MPEG_CX2341X_STREAM_INSERT_NAV_PACKETS = (V4L2_CID_CODEC_CX2341X_BASE+11);

/*  MPEG-class control IDs specific to the Samsung MFC 5.1 driver as defined by V4L2 */
export const V4L2_CID_CODEC_MFC51_BASE = (V4L2_CTRL_CLASS_CODEC | 0x1100);

export const V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY = (V4L2_CID_CODEC_MFC51_BASE+0);
export const V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY_ENABLE = (V4L2_CID_CODEC_MFC51_BASE+1);
export const V4L2_CID_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE = (V4L2_CID_CODEC_MFC51_BASE+2);
export enum v4l2_mpeg_mfc51_video_frame_skip_mode {
	V4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_DISABLED		= 0,
	V4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_LEVEL_LIMIT	= 1,
	V4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_BUF_LIMIT		= 2,
};
export const V4L2_CID_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE = (V4L2_CID_CODEC_MFC51_BASE+3);
export enum v4l2_mpeg_mfc51_video_force_frame_type {
	V4L2_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE_DISABLED		= 0,
	V4L2_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE_I_FRAME		= 1,
	V4L2_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE_NOT_CODED	= 2,
};
export const V4L2_CID_MPEG_MFC51_VIDEO_PADDING = (V4L2_CID_CODEC_MFC51_BASE+4);
export const V4L2_CID_MPEG_MFC51_VIDEO_PADDING_YUV = (V4L2_CID_CODEC_MFC51_BASE+5);
export const V4L2_CID_MPEG_MFC51_VIDEO_RC_FIXED_TARGET_BIT = (V4L2_CID_CODEC_MFC51_BASE+6);
export const V4L2_CID_MPEG_MFC51_VIDEO_RC_REACTION_COEFF = (V4L2_CID_CODEC_MFC51_BASE+7);
export const V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_ACTIVITY = (V4L2_CID_CODEC_MFC51_BASE+50);
export const V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_DARK = (V4L2_CID_CODEC_MFC51_BASE+51);
export const V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_SMOOTH = (V4L2_CID_CODEC_MFC51_BASE+52);
export const V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_STATIC = (V4L2_CID_CODEC_MFC51_BASE+53);
export const V4L2_CID_MPEG_MFC51_VIDEO_H264_NUM_REF_PIC_FOR_P = (V4L2_CID_CODEC_MFC51_BASE+54);

/*  Camera class control IDs */

export const V4L2_CID_CAMERA_CLASS_BASE = (V4L2_CTRL_CLASS_CAMERA | 0x900);
export const V4L2_CID_CAMERA_CLASS = (V4L2_CTRL_CLASS_CAMERA | 1);

export const V4L2_CID_EXPOSURE_AUTO = (V4L2_CID_CAMERA_CLASS_BASE+1);
export enum  v4l2_exposure_auto_type {
	V4L2_EXPOSURE_AUTO = 0,
	V4L2_EXPOSURE_MANUAL = 1,
	V4L2_EXPOSURE_SHUTTER_PRIORITY = 2,
	V4L2_EXPOSURE_APERTURE_PRIORITY = 3
};
export const V4L2_CID_EXPOSURE_ABSOLUTE = (V4L2_CID_CAMERA_CLASS_BASE+2);
export const V4L2_CID_EXPOSURE_AUTO_PRIORITY = (V4L2_CID_CAMERA_CLASS_BASE+3);

export const V4L2_CID_PAN_RELATIVE = (V4L2_CID_CAMERA_CLASS_BASE+4);
export const V4L2_CID_TILT_RELATIVE = (V4L2_CID_CAMERA_CLASS_BASE+5);
export const V4L2_CID_PAN_RESET = (V4L2_CID_CAMERA_CLASS_BASE+6);
export const V4L2_CID_TILT_RESET = (V4L2_CID_CAMERA_CLASS_BASE+7);

export const V4L2_CID_PAN_ABSOLUTE = (V4L2_CID_CAMERA_CLASS_BASE+8);
export const V4L2_CID_TILT_ABSOLUTE = (V4L2_CID_CAMERA_CLASS_BASE+9);

export const V4L2_CID_FOCUS_ABSOLUTE = (V4L2_CID_CAMERA_CLASS_BASE+10);
export const V4L2_CID_FOCUS_RELATIVE = (V4L2_CID_CAMERA_CLASS_BASE+11);
export const V4L2_CID_FOCUS_AUTO = (V4L2_CID_CAMERA_CLASS_BASE+12);

export const V4L2_CID_ZOOM_ABSOLUTE = (V4L2_CID_CAMERA_CLASS_BASE+13);
export const V4L2_CID_ZOOM_RELATIVE = (V4L2_CID_CAMERA_CLASS_BASE+14);
export const V4L2_CID_ZOOM_CONTINUOUS = (V4L2_CID_CAMERA_CLASS_BASE+15);

export const V4L2_CID_PRIVACY = (V4L2_CID_CAMERA_CLASS_BASE+16);

export const V4L2_CID_IRIS_ABSOLUTE = (V4L2_CID_CAMERA_CLASS_BASE+17);
export const V4L2_CID_IRIS_RELATIVE = (V4L2_CID_CAMERA_CLASS_BASE+18);

export const V4L2_CID_AUTO_EXPOSURE_BIAS = (V4L2_CID_CAMERA_CLASS_BASE+19);

export const V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE = (V4L2_CID_CAMERA_CLASS_BASE+20);
export enum v4l2_auto_n_preset_white_balance {
	V4L2_WHITE_BALANCE_MANUAL		= 0,
	V4L2_WHITE_BALANCE_AUTO			= 1,
	V4L2_WHITE_BALANCE_INCANDESCENT		= 2,
	V4L2_WHITE_BALANCE_FLUORESCENT		= 3,
	V4L2_WHITE_BALANCE_FLUORESCENT_H	= 4,
	V4L2_WHITE_BALANCE_HORIZON		= 5,
	V4L2_WHITE_BALANCE_DAYLIGHT		= 6,
	V4L2_WHITE_BALANCE_FLASH		= 7,
	V4L2_WHITE_BALANCE_CLOUDY		= 8,
	V4L2_WHITE_BALANCE_SHADE		= 9,
};

export const V4L2_CID_WIDE_DYNAMIC_RANGE = (V4L2_CID_CAMERA_CLASS_BASE+21);
export const V4L2_CID_IMAGE_STABILIZATION = (V4L2_CID_CAMERA_CLASS_BASE+22);

export const V4L2_CID_ISO_SENSITIVITY = (V4L2_CID_CAMERA_CLASS_BASE+23);
export const V4L2_CID_ISO_SENSITIVITY_AUTO = (V4L2_CID_CAMERA_CLASS_BASE+24);
export enum v4l2_iso_sensitivity_auto_type {
	V4L2_ISO_SENSITIVITY_MANUAL		= 0,
	V4L2_ISO_SENSITIVITY_AUTO		= 1,
};

export const V4L2_CID_EXPOSURE_METERING = (V4L2_CID_CAMERA_CLASS_BASE+25);
export enum v4l2_exposure_metering {
	V4L2_EXPOSURE_METERING_AVERAGE		= 0,
	V4L2_EXPOSURE_METERING_CENTER_WEIGHTED	= 1,
	V4L2_EXPOSURE_METERING_SPOT		= 2,
	V4L2_EXPOSURE_METERING_MATRIX		= 3,
};

export const V4L2_CID_SCENE_MODE = (V4L2_CID_CAMERA_CLASS_BASE+26);
export enum v4l2_scene_mode {
	V4L2_SCENE_MODE_NONE			= 0,
	V4L2_SCENE_MODE_BACKLIGHT		= 1,
	V4L2_SCENE_MODE_BEACH_SNOW		= 2,
	V4L2_SCENE_MODE_CANDLE_LIGHT		= 3,
	V4L2_SCENE_MODE_DAWN_DUSK		= 4,
	V4L2_SCENE_MODE_FALL_COLORS		= 5,
	V4L2_SCENE_MODE_FIREWORKS		= 6,
	V4L2_SCENE_MODE_LANDSCAPE		= 7,
	V4L2_SCENE_MODE_NIGHT			= 8,
	V4L2_SCENE_MODE_PARTY_INDOOR		= 9,
	V4L2_SCENE_MODE_PORTRAIT		= 10,
	V4L2_SCENE_MODE_SPORTS			= 11,
	V4L2_SCENE_MODE_SUNSET			= 12,
	V4L2_SCENE_MODE_TEXT			= 13,
};

export const V4L2_CID_3A_LOCK = (V4L2_CID_CAMERA_CLASS_BASE+27);
export const V4L2_LOCK_EXPOSURE = (1 << 0);
export const V4L2_LOCK_WHITE_BALANCE = (1 << 1);
export const V4L2_LOCK_FOCUS = (1 << 2);

export const V4L2_CID_AUTO_FOCUS_START = (V4L2_CID_CAMERA_CLASS_BASE+28);
export const V4L2_CID_AUTO_FOCUS_STOP = (V4L2_CID_CAMERA_CLASS_BASE+29);
export const V4L2_CID_AUTO_FOCUS_STATUS = (V4L2_CID_CAMERA_CLASS_BASE+30);
export const V4L2_AUTO_FOCUS_STATUS_IDLE = (0 << 0);
export const V4L2_AUTO_FOCUS_STATUS_BUSY = (1 << 0);
export const V4L2_AUTO_FOCUS_STATUS_REACHED = (1 << 1);
export const V4L2_AUTO_FOCUS_STATUS_FAILED = (1 << 2);

export const V4L2_CID_AUTO_FOCUS_RANGE = (V4L2_CID_CAMERA_CLASS_BASE+31);
export enum v4l2_auto_focus_range {
	V4L2_AUTO_FOCUS_RANGE_AUTO		= 0,
	V4L2_AUTO_FOCUS_RANGE_NORMAL		= 1,
	V4L2_AUTO_FOCUS_RANGE_MACRO		= 2,
	V4L2_AUTO_FOCUS_RANGE_INFINITY		= 3,
};

export const V4L2_CID_PAN_SPEED = (V4L2_CID_CAMERA_CLASS_BASE+32);
export const V4L2_CID_TILT_SPEED = (V4L2_CID_CAMERA_CLASS_BASE+33);

export const V4L2_CID_CAMERA_ORIENTATION = (V4L2_CID_CAMERA_CLASS_BASE+34);
export const V4L2_CAMERA_ORIENTATION_FRONT = 0;
export const V4L2_CAMERA_ORIENTATION_BACK = 1;
export const V4L2_CAMERA_ORIENTATION_EXTERNAL = 2;

export const V4L2_CID_CAMERA_SENSOR_ROTATION = (V4L2_CID_CAMERA_CLASS_BASE+35);

/* FM Modulator class control IDs */

export const V4L2_CID_FM_TX_CLASS_BASE = (V4L2_CTRL_CLASS_FM_TX | 0x900);
export const V4L2_CID_FM_TX_CLASS = (V4L2_CTRL_CLASS_FM_TX | 1);

export const V4L2_CID_RDS_TX_DEVIATION = (V4L2_CID_FM_TX_CLASS_BASE + 1);
export const V4L2_CID_RDS_TX_PI = (V4L2_CID_FM_TX_CLASS_BASE + 2);
export const V4L2_CID_RDS_TX_PTY = (V4L2_CID_FM_TX_CLASS_BASE + 3);
export const V4L2_CID_RDS_TX_PS_NAME = (V4L2_CID_FM_TX_CLASS_BASE + 5);
export const V4L2_CID_RDS_TX_RADIO_TEXT = (V4L2_CID_FM_TX_CLASS_BASE + 6);
export const V4L2_CID_RDS_TX_MONO_STEREO = (V4L2_CID_FM_TX_CLASS_BASE + 7);
export const V4L2_CID_RDS_TX_ARTIFICIAL_HEAD = (V4L2_CID_FM_TX_CLASS_BASE + 8);
export const V4L2_CID_RDS_TX_COMPRESSED = (V4L2_CID_FM_TX_CLASS_BASE + 9);
export const V4L2_CID_RDS_TX_DYNAMIC_PTY = (V4L2_CID_FM_TX_CLASS_BASE + 10);
export const V4L2_CID_RDS_TX_TRAFFIC_ANNOUNCEMENT = (V4L2_CID_FM_TX_CLASS_BASE + 11);
export const V4L2_CID_RDS_TX_TRAFFIC_PROGRAM = (V4L2_CID_FM_TX_CLASS_BASE + 12);
export const V4L2_CID_RDS_TX_MUSIC_SPEECH = (V4L2_CID_FM_TX_CLASS_BASE + 13);
export const V4L2_CID_RDS_TX_ALT_FREQS_ENABLE = (V4L2_CID_FM_TX_CLASS_BASE + 14);
export const V4L2_CID_RDS_TX_ALT_FREQS = (V4L2_CID_FM_TX_CLASS_BASE + 15);

export const V4L2_CID_AUDIO_LIMITER_ENABLED = (V4L2_CID_FM_TX_CLASS_BASE + 64);
export const V4L2_CID_AUDIO_LIMITER_RELEASE_TIME = (V4L2_CID_FM_TX_CLASS_BASE + 65);
export const V4L2_CID_AUDIO_LIMITER_DEVIATION = (V4L2_CID_FM_TX_CLASS_BASE + 66);

export const V4L2_CID_AUDIO_COMPRESSION_ENABLED = (V4L2_CID_FM_TX_CLASS_BASE + 80);
export const V4L2_CID_AUDIO_COMPRESSION_GAIN = (V4L2_CID_FM_TX_CLASS_BASE + 81);
export const V4L2_CID_AUDIO_COMPRESSION_THRESHOLD = (V4L2_CID_FM_TX_CLASS_BASE + 82);
export const V4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME = (V4L2_CID_FM_TX_CLASS_BASE + 83);
export const V4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME = (V4L2_CID_FM_TX_CLASS_BASE + 84);

export const V4L2_CID_PILOT_TONE_ENABLED = (V4L2_CID_FM_TX_CLASS_BASE + 96);
export const V4L2_CID_PILOT_TONE_DEVIATION = (V4L2_CID_FM_TX_CLASS_BASE + 97);
export const V4L2_CID_PILOT_TONE_FREQUENCY = (V4L2_CID_FM_TX_CLASS_BASE + 98);

export const V4L2_CID_TUNE_PREEMPHASIS = (V4L2_CID_FM_TX_CLASS_BASE + 112);
export enum v4l2_preemphasis {
	V4L2_PREEMPHASIS_DISABLED	= 0,
	V4L2_PREEMPHASIS_50_uS		= 1,
	V4L2_PREEMPHASIS_75_uS		= 2,
};
export const V4L2_CID_TUNE_POWER_LEVEL = (V4L2_CID_FM_TX_CLASS_BASE + 113);
export const V4L2_CID_TUNE_ANTENNA_CAPACITOR = (V4L2_CID_FM_TX_CLASS_BASE + 114);


/* Flash and privacy (indicator) light controls */

export const V4L2_CID_FLASH_CLASS_BASE = (V4L2_CTRL_CLASS_FLASH | 0x900);
export const V4L2_CID_FLASH_CLASS = (V4L2_CTRL_CLASS_FLASH | 1);

export const V4L2_CID_FLASH_LED_MODE = (V4L2_CID_FLASH_CLASS_BASE + 1);
export enum v4l2_flash_led_mode {
	V4L2_FLASH_LED_MODE_NONE,
	V4L2_FLASH_LED_MODE_FLASH,
	V4L2_FLASH_LED_MODE_TORCH,
};

export const V4L2_CID_FLASH_STROBE_SOURCE = (V4L2_CID_FLASH_CLASS_BASE + 2);
export enum v4l2_flash_strobe_source {
	V4L2_FLASH_STROBE_SOURCE_SOFTWARE,
	V4L2_FLASH_STROBE_SOURCE_EXTERNAL,
};

export const V4L2_CID_FLASH_STROBE = (V4L2_CID_FLASH_CLASS_BASE + 3);
export const V4L2_CID_FLASH_STROBE_STOP = (V4L2_CID_FLASH_CLASS_BASE + 4);
export const V4L2_CID_FLASH_STROBE_STATUS = (V4L2_CID_FLASH_CLASS_BASE + 5);

export const V4L2_CID_FLASH_TIMEOUT = (V4L2_CID_FLASH_CLASS_BASE + 6);
export const V4L2_CID_FLASH_INTENSITY = (V4L2_CID_FLASH_CLASS_BASE + 7);
export const V4L2_CID_FLASH_TORCH_INTENSITY = (V4L2_CID_FLASH_CLASS_BASE + 8);
export const V4L2_CID_FLASH_INDICATOR_INTENSITY = (V4L2_CID_FLASH_CLASS_BASE + 9);

export const V4L2_CID_FLASH_FAULT = (V4L2_CID_FLASH_CLASS_BASE + 10);
export const V4L2_FLASH_FAULT_OVER_VOLTAGE = (1 << 0);
export const V4L2_FLASH_FAULT_TIMEOUT = (1 << 1);
export const V4L2_FLASH_FAULT_OVER_TEMPERATURE = (1 << 2);
export const V4L2_FLASH_FAULT_SHORT_CIRCUIT = (1 << 3);
export const V4L2_FLASH_FAULT_OVER_CURRENT = (1 << 4);
export const V4L2_FLASH_FAULT_INDICATOR = (1 << 5);
export const V4L2_FLASH_FAULT_UNDER_VOLTAGE = (1 << 6);
export const V4L2_FLASH_FAULT_INPUT_VOLTAGE = (1 << 7);
export const V4L2_FLASH_FAULT_LED_OVER_TEMPERATURE = (1 << 8);

export const V4L2_CID_FLASH_CHARGE = (V4L2_CID_FLASH_CLASS_BASE + 11);
export const V4L2_CID_FLASH_READY = (V4L2_CID_FLASH_CLASS_BASE + 12);


/* JPEG-class control IDs */

export const V4L2_CID_JPEG_CLASS_BASE = (V4L2_CTRL_CLASS_JPEG | 0x900);
export const V4L2_CID_JPEG_CLASS = (V4L2_CTRL_CLASS_JPEG | 1);

export const V4L2_CID_JPEG_CHROMA_SUBSAMPLING = (V4L2_CID_JPEG_CLASS_BASE + 1);
export enum v4l2_jpeg_chroma_subsampling {
	V4L2_JPEG_CHROMA_SUBSAMPLING_444	= 0,
	V4L2_JPEG_CHROMA_SUBSAMPLING_422	= 1,
	V4L2_JPEG_CHROMA_SUBSAMPLING_420	= 2,
	V4L2_JPEG_CHROMA_SUBSAMPLING_411	= 3,
	V4L2_JPEG_CHROMA_SUBSAMPLING_410	= 4,
	V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY	= 5,
};
export const V4L2_CID_JPEG_RESTART_INTERVAL = (V4L2_CID_JPEG_CLASS_BASE + 2);
export const V4L2_CID_JPEG_COMPRESSION_QUALITY = (V4L2_CID_JPEG_CLASS_BASE + 3);

export const V4L2_CID_JPEG_ACTIVE_MARKER = (V4L2_CID_JPEG_CLASS_BASE + 4);
export const V4L2_JPEG_ACTIVE_MARKER_APP0 = (1 << 0);
export const V4L2_JPEG_ACTIVE_MARKER_APP1 = (1 << 1);
export const V4L2_JPEG_ACTIVE_MARKER_COM = (1 << 16);
export const V4L2_JPEG_ACTIVE_MARKER_DQT = (1 << 17);
export const V4L2_JPEG_ACTIVE_MARKER_DHT = (1 << 18);


/* Image source controls */
export const V4L2_CID_IMAGE_SOURCE_CLASS_BASE = (V4L2_CTRL_CLASS_IMAGE_SOURCE | 0x900);
export const V4L2_CID_IMAGE_SOURCE_CLASS = (V4L2_CTRL_CLASS_IMAGE_SOURCE | 1);

export const V4L2_CID_VBLANK = (V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 1);
export const V4L2_CID_HBLANK = (V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 2);
export const V4L2_CID_ANALOGUE_GAIN = (V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 3);
export const V4L2_CID_TEST_PATTERN_RED = (V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 4);
export const V4L2_CID_TEST_PATTERN_GREENR = (V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 5);
export const V4L2_CID_TEST_PATTERN_BLUE = (V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 6);
export const V4L2_CID_TEST_PATTERN_GREENB = (V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 7);
export const V4L2_CID_UNIT_CELL_SIZE = (V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 8);


/* Image processing controls */

export const V4L2_CID_IMAGE_PROC_CLASS_BASE = (V4L2_CTRL_CLASS_IMAGE_PROC | 0x900);
export const V4L2_CID_IMAGE_PROC_CLASS = (V4L2_CTRL_CLASS_IMAGE_PROC | 1);

export const V4L2_CID_LINK_FREQ = (V4L2_CID_IMAGE_PROC_CLASS_BASE + 1);
export const V4L2_CID_PIXEL_RATE = (V4L2_CID_IMAGE_PROC_CLASS_BASE + 2);
export const V4L2_CID_TEST_PATTERN = (V4L2_CID_IMAGE_PROC_CLASS_BASE + 3);
export const V4L2_CID_DEINTERLACING_MODE = (V4L2_CID_IMAGE_PROC_CLASS_BASE + 4);
export const V4L2_CID_DIGITAL_GAIN = (V4L2_CID_IMAGE_PROC_CLASS_BASE + 5);

/*  DV-class control IDs defined by V4L2 */
export const V4L2_CID_DV_CLASS_BASE = (V4L2_CTRL_CLASS_DV | 0x900);
export const V4L2_CID_DV_CLASS = (V4L2_CTRL_CLASS_DV | 1);

export const V4L2_CID_DV_TX_HOTPLUG = (V4L2_CID_DV_CLASS_BASE + 1);
export const V4L2_CID_DV_TX_RXSENSE = (V4L2_CID_DV_CLASS_BASE + 2);
export const V4L2_CID_DV_TX_EDID_PRESENT = (V4L2_CID_DV_CLASS_BASE + 3);
export const V4L2_CID_DV_TX_MODE = (V4L2_CID_DV_CLASS_BASE + 4);
export enum v4l2_dv_tx_mode {
	V4L2_DV_TX_MODE_DVI_D	= 0,
	V4L2_DV_TX_MODE_HDMI	= 1,
};
export const V4L2_CID_DV_TX_RGB_RANGE = (V4L2_CID_DV_CLASS_BASE + 5);
export enum v4l2_dv_rgb_range {
	V4L2_DV_RGB_RANGE_AUTO	  = 0,
	V4L2_DV_RGB_RANGE_LIMITED = 1,
	V4L2_DV_RGB_RANGE_FULL	  = 2,
};

export const V4L2_CID_DV_TX_IT_CONTENT_TYPE = (V4L2_CID_DV_CLASS_BASE + 6);
export enum v4l2_dv_it_content_type {
	V4L2_DV_IT_CONTENT_TYPE_GRAPHICS  = 0,
	V4L2_DV_IT_CONTENT_TYPE_PHOTO	  = 1,
	V4L2_DV_IT_CONTENT_TYPE_CINEMA	  = 2,
	V4L2_DV_IT_CONTENT_TYPE_GAME	  = 3,
	V4L2_DV_IT_CONTENT_TYPE_NO_ITC	  = 4,
};

export const V4L2_CID_DV_RX_POWER_PRESENT = (V4L2_CID_DV_CLASS_BASE + 100);
export const V4L2_CID_DV_RX_RGB_RANGE = (V4L2_CID_DV_CLASS_BASE + 101);
export const V4L2_CID_DV_RX_IT_CONTENT_TYPE = (V4L2_CID_DV_CLASS_BASE + 102);

export const V4L2_CID_FM_RX_CLASS_BASE = (V4L2_CTRL_CLASS_FM_RX | 0x900);
export const V4L2_CID_FM_RX_CLASS = (V4L2_CTRL_CLASS_FM_RX | 1);

export const V4L2_CID_TUNE_DEEMPHASIS = (V4L2_CID_FM_RX_CLASS_BASE + 1);
export enum v4l2_deemphasis {
	V4L2_DEEMPHASIS_DISABLED	= v4l2_preemphasis.V4L2_PREEMPHASIS_DISABLED,
	V4L2_DEEMPHASIS_50_uS		= v4l2_preemphasis.V4L2_PREEMPHASIS_50_uS,
	V4L2_DEEMPHASIS_75_uS		= v4l2_preemphasis.V4L2_PREEMPHASIS_75_uS,
};

export const V4L2_CID_RDS_RECEPTION = (V4L2_CID_FM_RX_CLASS_BASE + 2);
export const V4L2_CID_RDS_RX_PTY = (V4L2_CID_FM_RX_CLASS_BASE + 3);
export const V4L2_CID_RDS_RX_PS_NAME = (V4L2_CID_FM_RX_CLASS_BASE + 4);
export const V4L2_CID_RDS_RX_RADIO_TEXT = (V4L2_CID_FM_RX_CLASS_BASE + 5);
export const V4L2_CID_RDS_RX_TRAFFIC_ANNOUNCEMENT = (V4L2_CID_FM_RX_CLASS_BASE + 6);
export const V4L2_CID_RDS_RX_TRAFFIC_PROGRAM = (V4L2_CID_FM_RX_CLASS_BASE + 7);
export const V4L2_CID_RDS_RX_MUSIC_SPEECH = (V4L2_CID_FM_RX_CLASS_BASE + 8);

export const V4L2_CID_RF_TUNER_CLASS_BASE = (V4L2_CTRL_CLASS_RF_TUNER | 0x900);
export const V4L2_CID_RF_TUNER_CLASS = (V4L2_CTRL_CLASS_RF_TUNER | 1);

export const V4L2_CID_RF_TUNER_BANDWIDTH_AUTO = (V4L2_CID_RF_TUNER_CLASS_BASE + 11);
export const V4L2_CID_RF_TUNER_BANDWIDTH = (V4L2_CID_RF_TUNER_CLASS_BASE + 12);
export const V4L2_CID_RF_TUNER_RF_GAIN = (V4L2_CID_RF_TUNER_CLASS_BASE + 32);
export const V4L2_CID_RF_TUNER_LNA_GAIN_AUTO = (V4L2_CID_RF_TUNER_CLASS_BASE + 41);
export const V4L2_CID_RF_TUNER_LNA_GAIN = (V4L2_CID_RF_TUNER_CLASS_BASE + 42);
export const V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO = (V4L2_CID_RF_TUNER_CLASS_BASE + 51);
export const V4L2_CID_RF_TUNER_MIXER_GAIN = (V4L2_CID_RF_TUNER_CLASS_BASE + 52);
export const V4L2_CID_RF_TUNER_IF_GAIN_AUTO = (V4L2_CID_RF_TUNER_CLASS_BASE + 61);
export const V4L2_CID_RF_TUNER_IF_GAIN = (V4L2_CID_RF_TUNER_CLASS_BASE + 62);
export const V4L2_CID_RF_TUNER_PLL_LOCK = (V4L2_CID_RF_TUNER_CLASS_BASE + 91);


/*  Detection-class control IDs defined by V4L2 */
export const V4L2_CID_DETECT_CLASS_BASE = (V4L2_CTRL_CLASS_DETECT | 0x900);
export const V4L2_CID_DETECT_CLASS = (V4L2_CTRL_CLASS_DETECT | 1);

export const V4L2_CID_DETECT_MD_MODE = (V4L2_CID_DETECT_CLASS_BASE + 1);
export enum v4l2_detect_md_mode {
	V4L2_DETECT_MD_MODE_DISABLED		= 0,
	V4L2_DETECT_MD_MODE_GLOBAL		= 1,
	V4L2_DETECT_MD_MODE_THRESHOLD_GRID	= 2,
	V4L2_DETECT_MD_MODE_REGION_GRID		= 3,
};
export const V4L2_CID_DETECT_MD_GLOBAL_THRESHOLD = (V4L2_CID_DETECT_CLASS_BASE + 2);
export const V4L2_CID_DETECT_MD_THRESHOLD_GRID = (V4L2_CID_DETECT_CLASS_BASE + 3);
export const V4L2_CID_DETECT_MD_REGION_GRID = (V4L2_CID_DETECT_CLASS_BASE + 4);


/*  Stateless CODECs controls */
export const V4L2_CID_CODEC_STATELESS_BASE = (V4L2_CTRL_CLASS_CODEC_STATELESS | 0x900);
export const V4L2_CID_CODEC_STATELESS_CLASS = (V4L2_CTRL_CLASS_CODEC_STATELESS | 1);

export const V4L2_CID_STATELESS_H264_DECODE_MODE = (V4L2_CID_CODEC_STATELESS_BASE + 0);
/**
 * enum v4l2_stateless_h264_decode_mode - Decoding mode
 *
 * @V4L2_STATELESS_H264_DECODE_MODE_SLICE_BASED: indicates that decoding
 * is performed one slice at a time. In this mode,
 * V4L2_CID_STATELESS_H264_SLICE_PARAMS must contain the parsed slice
 * parameters and the OUTPUT buffer must contain a single slice.
 * V4L2_BUF_CAP_SUPPORTS_M2M_HOLD_CAPTURE_BUF feature is used
 * in order to support multislice frames.
 * @V4L2_STATELESS_H264_DECODE_MODE_FRAME_BASED: indicates that
 * decoding is performed per frame. The OUTPUT buffer must contain
 * all slices and also both fields. This mode is typically supported
 * by device drivers that are able to parse the slice(s) header(s)
 * in hardware. When this mode is selected,
 * V4L2_CID_STATELESS_H264_SLICE_PARAMS is not used.
 */
export enum v4l2_stateless_h264_decode_mode {
	V4L2_STATELESS_H264_DECODE_MODE_SLICE_BASED,
	V4L2_STATELESS_H264_DECODE_MODE_FRAME_BASED,
};

export const V4L2_CID_STATELESS_H264_START_CODE = (V4L2_CID_CODEC_STATELESS_BASE + 1);
/**
 * enum v4l2_stateless_h264_start_code - Start code
 *
 * @V4L2_STATELESS_H264_START_CODE_NONE: slices are passed
 * to the driver without any start code.
 * @V4L2_STATELESS_H264_START_CODE_ANNEX_B: slices are passed
 * to the driver with an Annex B start code prefix
 * (legal start codes can be 3-bytes 0x000001 or 4-bytes 0x00000001).
 * This mode is typically supported by device drivers that parse
 * the start code in hardware.
 */
export enum v4l2_stateless_h264_start_code {
	V4L2_STATELESS_H264_START_CODE_NONE,
	V4L2_STATELESS_H264_START_CODE_ANNEX_B,
};

export const V4L2_H264_SPS_CONSTRAINT_SET0_FLAG = 0x01;
export const V4L2_H264_SPS_CONSTRAINT_SET1_FLAG = 0x02;
export const V4L2_H264_SPS_CONSTRAINT_SET2_FLAG = 0x04;
export const V4L2_H264_SPS_CONSTRAINT_SET3_FLAG = 0x08;
export const V4L2_H264_SPS_CONSTRAINT_SET4_FLAG = 0x10;
export const V4L2_H264_SPS_CONSTRAINT_SET5_FLAG = 0x20;

export const V4L2_H264_SPS_FLAG_SEPARATE_COLOUR_PLANE = 0x01;
export const V4L2_H264_SPS_FLAG_QPPRIME_Y_ZERO_TRANSFORM_BYPASS = 0x02;
export const V4L2_H264_SPS_FLAG_DELTA_PIC_ORDER_ALWAYS_ZERO = 0x04;
export const V4L2_H264_SPS_FLAG_GAPS_IN_FRAME_NUM_VALUE_ALLOWED = 0x08;
export const V4L2_H264_SPS_FLAG_FRAME_MBS_ONLY = 0x10;
export const V4L2_H264_SPS_FLAG_MB_ADAPTIVE_FRAME_FIELD = 0x20;
export const V4L2_H264_SPS_FLAG_DIRECT_8X8_INFERENCE = 0x40;

export const V4L2_CID_STATELESS_H264_SPS = (V4L2_CID_CODEC_STATELESS_BASE + 2);
/**
 * struct v4l2_ctrl_h264_sps - H264 sequence parameter set
 *
 * All the members on this sequence parameter set structure match the
 * sequence parameter set syntax as specified by the H264 specification.
 *
 * @profile_idc: see H264 specification.
 * @constraint_set_flags: see H264 specification.
 * @level_idc: see H264 specification.
 * @seq_parameter_set_id: see H264 specification.
 * @chroma_format_idc: see H264 specification.
 * @bit_depth_luma_minus8: see H264 specification.
 * @bit_depth_chroma_minus8: see H264 specification.
 * @log2_max_frame_num_minus4: see H264 specification.
 * @pic_order_cnt_type: see H264 specification.
 * @log2_max_pic_order_cnt_lsb_minus4: see H264 specification.
 * @max_num_ref_frames: see H264 specification.
 * @num_ref_frames_in_pic_order_cnt_cycle: see H264 specification.
 * @offset_for_ref_frame: see H264 specification.
 * @offset_for_non_ref_pic: see H264 specification.
 * @offset_for_top_to_bottom_field: see H264 specification.
 * @pic_width_in_mbs_minus1: see H264 specification.
 * @pic_height_in_map_units_minus1: see H264 specification.
 * @flags: see V4L2_H264_SPS_FLAG_{}.
 */
export const v4l2_ctrl_h264_sps = StructType({
	profile_idc: ref.types.uint8,
	constraint_set_flags: ref.types.uint8,
	level_idc: ref.types.uint8,
	seq_parameter_set_id: ref.types.uint8,
	chroma_format_idc: ref.types.uint8,
	bit_depth_luma_minus8: ref.types.uint8,
	bit_depth_chroma_minus8: ref.types.uint8,
	log2_max_frame_num_minus4: ref.types.uint8,
	pic_order_cnt_type: ref.types.uint8,
	log2_max_pic_order_cnt_lsb_minus4: ref.types.uint8,
	max_num_ref_frames: ref.types.uint8,
	num_ref_frames_in_pic_order_cnt_cycle: ref.types.uint8,
	offset_for_ref_frame: new ArrayType(ref.types.int32, 255),
	offset_for_non_ref_pic: ref.types.int32,
	offset_for_top_to_bottom_field: ref.types.int32,
	pic_width_in_mbs_minus1: ref.types.uint16,
	pic_height_in_map_units_minus1: ref.types.uint16,
	flags: ref.types.uint32,
});

export function V4L2_H264_SPS_HAS_CHROMA_FORMAT(sps: InstanceType<typeof v4l2_ctrl_h264_sps>): boolean {
	const profile_idc = sps.profile_idc;

	return (
		profile_idc === 100 ||
		profile_idc === 110 ||
		profile_idc === 122 ||
		profile_idc === 244 ||
		profile_idc === 44 ||
		profile_idc === 83 ||
		profile_idc === 86 ||
		profile_idc === 118 ||
		profile_idc === 128 ||
		profile_idc === 138 ||
		profile_idc === 139 ||
		profile_idc === 134 ||
		profile_idc === 135
	);
}

export const V4L2_H264_PPS_FLAG_ENTROPY_CODING_MODE = 0x0001;
export const V4L2_H264_PPS_FLAG_BOTTOM_FIELD_PIC_ORDER_IN_FRAME_PRESENT = 0x0002;
export const V4L2_H264_PPS_FLAG_WEIGHTED_PRED = 0x0004;
export const V4L2_H264_PPS_FLAG_DEBLOCKING_FILTER_CONTROL_PRESENT = 0x0008;
export const V4L2_H264_PPS_FLAG_CONSTRAINED_INTRA_PRED = 0x0010;
export const V4L2_H264_PPS_FLAG_REDUNDANT_PIC_CNT_PRESENT = 0x0020;
export const V4L2_H264_PPS_FLAG_TRANSFORM_8X8_MODE = 0x0040;
export const V4L2_H264_PPS_FLAG_SCALING_MATRIX_PRESENT = 0x0080;

export const V4L2_CID_STATELESS_H264_PPS = (V4L2_CID_CODEC_STATELESS_BASE + 3);
/**
 * struct v4l2_ctrl_h264_pps - H264 picture parameter set
 *
 * Except where noted, all the members on this picture parameter set
 * structure match the picture parameter set syntax as specified
 * by the H264 specification.
 *
 * In particular, V4L2_H264_PPS_FLAG_SCALING_MATRIX_PRESENT flag
 * has a specific meaning. This flag should be set if a non-flat
 * scaling matrix applies to the picture. In this case, applications
 * are expected to use V4L2_CID_STATELESS_H264_SCALING_MATRIX,
 * to pass the values of the non-flat matrices.
 *
 * @pic_parameter_set_id: see H264 specification.
 * @seq_parameter_set_id: see H264 specification.
 * @num_slice_groups_minus1: see H264 specification.
 * @num_ref_idx_l0_default_active_minus1: see H264 specification.
 * @num_ref_idx_l1_default_active_minus1: see H264 specification.
 * @weighted_bipred_idc: see H264 specification.
 * @pic_init_qp_minus26: see H264 specification.
 * @pic_init_qs_minus26: see H264 specification.
 * @chroma_qp_index_offset: see H264 specification.
 * @second_chroma_qp_index_offset: see H264 specification.
 * @flags: see V4L2_H264_PPS_FLAG_{}.
 */
export const v4l2_ctrl_h264_pps = StructType({
	pic_parameter_set_id: ref.types.uint8,
	seq_parameter_set_id: ref.types.uint8,
	num_slice_groups_minus1: ref.types.uint8,
	num_ref_idx_l0_default_active_minus1: ref.types.uint8,
	num_ref_idx_l1_default_active_minus1: ref.types.uint8,
	weighted_bipred_idc: ref.types.uint8,
	pic_init_qp_minus26: ref.types.int8,
	pic_init_qs_minus26: ref.types.int8,
	chroma_qp_index_offset: ref.types.int8,
	second_chroma_qp_index_offset: ref.types.int8,
	flags: ref.types.uint16,
});

export const V4L2_CID_STATELESS_H264_SCALING_MATRIX = (V4L2_CID_CODEC_STATELESS_BASE + 4);
/**
 * struct v4l2_ctrl_h264_scaling_matrix - H264 scaling matrices
 *
 * @scaling_list_4x4: scaling matrix after applying the inverse
 * scanning process. Expected list order is Intra Y, Intra Cb,
 * Intra Cr, Inter Y, Inter Cb, Inter Cr. The values on each
 * scaling list are expected in raster scan order.
 * @scaling_list_8x8: scaling matrix after applying the inverse
 * scanning process. Expected list order is Intra Y, Inter Y,
 * Intra Cb, Inter Cb, Intra Cr, Inter Cr. The values on each
 * scaling list are expected in raster scan order.
 *
 * Note that the list order is different for the 4x4 and 8x8
 * matrices as per the H264 specification, see table 7-2 "Assignment
 * of mnemonic names to scaling list indices and specification of
 * fall-back rule".
 */
export const v4l2_ctrl_h264_scaling_matrix = StructType({
	scaling_list_4x4: ArrayType(ArrayType(ref.types.uint8, 16), 6),
	scaling_list_8x8: ArrayType(ArrayType(ref.types.uint8, 64), 6),
});
  
export const v4l2_h264_weight_factors = StructType({
	luma_weight: ArrayType(ref.types.int16, 32),
	luma_offset: ArrayType(ref.types.int16, 32),
	chroma_weight: ArrayType(ArrayType(ref.types.int16, 2), 32),
	chroma_offset: ArrayType(ArrayType(ref.types.int16, 2), 32),
});

// export const V4L2_H264_CTRL_PRED_WEIGHTS_REQUIRED = (pps, slice) \;
// 	((((pps)->flags & V4L2_H264_PPS_FLAG_WEIGHTED_PRED) && \
// 	 ((slice)->slice_type == V4L2_H264_SLICE_TYPE_P || \
// 	  (slice)->slice_type == V4L2_H264_SLICE_TYPE_SP)) || \
// 	 ((pps)->weighted_bipred_idc == 1 && \
// 	  (slice)->slice_type == V4L2_H264_SLICE_TYPE_B))

export const V4L2_CID_STATELESS_H264_PRED_WEIGHTS = (V4L2_CID_CODEC_STATELESS_BASE + 5);
/**
 * struct v4l2_ctrl_h264_pred_weights - Prediction weight table
 *
 * Prediction weight table, which matches the syntax specified
 * by the H264 specification.
 *
 * @luma_log2_weight_denom: see H264 specification.
 * @chroma_log2_weight_denom: see H264 specification.
 * @weight_factors: luma and chroma weight factors.
 */
export const v4l2_ctrl_h264_pred_weights = StructType({
	luma_log2_weight_denom: ref.types.uint16,
	chroma_log2_weight_denom: ref.types.uint16,
	weight_factors: ArrayType(v4l2_h264_weight_factors, 2),
});

export const V4L2_H264_SLICE_TYPE_P = 0;
export const V4L2_H264_SLICE_TYPE_B = 1;
export const V4L2_H264_SLICE_TYPE_I = 2;
export const V4L2_H264_SLICE_TYPE_SP = 3;
export const V4L2_H264_SLICE_TYPE_SI = 4;

export const V4L2_H264_SLICE_FLAG_DIRECT_SPATIAL_MV_PRED = 0x01;
export const V4L2_H264_SLICE_FLAG_SP_FOR_SWITCH = 0x02;

export const V4L2_H264_TOP_FIELD_REF = 0x1;
export const V4L2_H264_BOTTOM_FIELD_REF = 0x2;
export const V4L2_H264_FRAME_REF = 0x3;

/**
 * struct v4l2_h264_reference - H264 picture reference
 *
 * @fields: indicates how the picture is referenced.
 * Valid values are V4L2_H264_{}_REF.
 * @index: index into v4l2_ctrl_h264_decode_params.dpb[].
 */
export const v4l2_h264_reference = StructType({
	fields: ref.types.uint8,
	index: ref.types.uint8,
});

/*
 * Maximum DPB size, as specified by section 'A.3.1 Level limits
 * common to the Baseline, Main, and Extended profiles'.
 */
export const V4L2_H264_NUM_DPB_ENTRIES = 16;
export const V4L2_H264_REF_LIST_LEN = (2 * V4L2_H264_NUM_DPB_ENTRIES);

export const V4L2_CID_STATELESS_H264_SLICE_PARAMS = (V4L2_CID_CODEC_STATELESS_BASE + 6);
/**
 * struct v4l2_ctrl_h264_slice_params - H264 slice parameters
 *
 * This structure holds the H264 syntax elements that are specified
 * as non-invariant for the slices in a given frame.
 *
 * Slice invariant syntax elements are contained in struct
 * v4l2_ctrl_h264_decode_params. This is done to reduce the API surface
 * on frame-based decoders, where slice header parsing is done by the
 * hardware.
 *
 * Slice invariant syntax elements are specified in specification section
 * "7.4.3 Slice header semantics".
 *
 * Except where noted, the members on this struct match the slice header syntax.
 *
 * @header_bit_size: offset in bits to slice_data() from the beginning of this slice.
 * @first_mb_in_slice: see H264 specification.
 * @slice_type: see H264 specification.
 * @colour_plane_id: see H264 specification.
 * @redundant_pic_cnt: see H264 specification.
 * @cabac_init_idc: see H264 specification.
 * @slice_qp_delta: see H264 specification.
 * @slice_qs_delta: see H264 specification.
 * @disable_deblocking_filter_idc: see H264 specification.
 * @slice_alpha_c0_offset_div2: see H264 specification.
 * @slice_beta_offset_div2: see H264 specification.
 * @num_ref_idx_l0_active_minus1: see H264 specification.
 * @num_ref_idx_l1_active_minus1: see H264 specification.
 * @reserved: padding field. Should be zeroed by applications.
 * @ref_pic_list0: reference picture list 0 after applying the per-slice modifications.
 * @ref_pic_list1: reference picture list 1 after applying the per-slice modifications.
 * @flags: see V4L2_H264_SLICE_FLAG_{}.
 */
export const v4l2_ctrl_h264_slice_params = StructType({
	header_bit_size: ref.types.uint32,
	first_mb_in_slice: ref.types.uint32,
	slice_type: ref.types.uint8,
	colour_plane_id: ref.types.uint8,
	redundant_pic_cnt: ref.types.uint8,
	cabac_init_idc: ref.types.uint8,
	slice_qp_delta: ref.types.int8,
	slice_qs_delta: ref.types.int8,
	disable_deblocking_filter_idc: ref.types.uint8,
	slice_alpha_c0_offset_div2: ref.types.int8,
	slice_beta_offset_div2: ref.types.int8,
	num_ref_idx_l0_active_minus1: ref.types.uint8,
	num_ref_idx_l1_active_minus1: ref.types.uint8,
	reserved: ref.types.uint8,
	ref_pic_list0: new ArrayType(v4l2_h264_reference, V4L2_H264_REF_LIST_LEN),
	ref_pic_list1: new ArrayType(v4l2_h264_reference, V4L2_H264_REF_LIST_LEN),
	flags: ref.types.uint32,
});

export const V4L2_H264_DPB_ENTRY_FLAG_VALID = 0x01;
export const V4L2_H264_DPB_ENTRY_FLAG_ACTIVE = 0x02;
export const V4L2_H264_DPB_ENTRY_FLAG_LONG_TERM = 0x04;
export const V4L2_H264_DPB_ENTRY_FLAG_FIELD = 0x08;

/**
 * struct v4l2_h264_dpb_entry - H264 decoded picture buffer entry
 *
 * @reference_ts: timestamp of the V4L2 capture buffer to use as reference.
 * The timestamp refers to the timestamp field in struct v4l2_buffer.
 * Use v4l2_timeval_to_ns() to convert the struct timeval to a __u64.
 * @pic_num: matches PicNum variable assigned during the reference
 * picture lists construction process.
 * @frame_num: frame identifier which matches frame_num syntax element.
 * @fields: indicates how the DPB entry is referenced. Valid values are
 * V4L2_H264_{}_REF.
 * @reserved: padding field. Should be zeroed by applications.
 * @top_field_order_cnt: matches TopFieldOrderCnt picture value.
 * @bottom_field_order_cnt: matches BottomFieldOrderCnt picture value.
 * Note that picture field is indicated by v4l2_buffer.field.
 * @flags: see V4L2_H264_DPB_ENTRY_FLAG_{}.
 */
export const v4l2_h264_dpb_entry = StructType({
	reference_ts: ref.types.uint64,
	pic_num: ref.types.uint32,
	frame_num: ref.types.uint16,
	fields: ref.types.uint8,
	reserved: new ArrayType(ref.types.uint8, 5),
	top_field_order_cnt: ref.types.int32,
	bottom_field_order_cnt: ref.types.int32,
	flags: ref.types.uint32,
});

export const V4L2_H264_DECODE_PARAM_FLAG_IDR_PIC = 0x01;
export const V4L2_H264_DECODE_PARAM_FLAG_FIELD_PIC = 0x02;
export const V4L2_H264_DECODE_PARAM_FLAG_BOTTOM_FIELD = 0x04;

export const V4L2_CID_STATELESS_H264_DECODE_PARAMS = (V4L2_CID_CODEC_STATELESS_BASE + 7);
/**
 * struct v4l2_ctrl_h264_decode_params - H264 decoding parameters
 *
 * @dpb: decoded picture buffer.
 * @nal_ref_idc: slice header syntax element.
 * @frame_num: slice header syntax element.
 * @top_field_order_cnt: matches TopFieldOrderCnt picture value.
 * @bottom_field_order_cnt: matches BottomFieldOrderCnt picture value.
 * Note that picture field is indicated by v4l2_buffer.field.
 * @idr_pic_id: slice header syntax element.
 * @pic_order_cnt_lsb: slice header syntax element.
 * @delta_pic_order_cnt_bottom: slice header syntax element.
 * @delta_pic_order_cnt0: slice header syntax element.
 * @delta_pic_order_cnt1: slice header syntax element.
 * @dec_ref_pic_marking_bit_size: size in bits of dec_ref_pic_marking()
 * syntax element.
 * @pic_order_cnt_bit_size: size in bits of pic order count syntax.
 * @slice_group_change_cycle: slice header syntax element.
 * @reserved: padding field. Should be zeroed by applications.
 * @flags: see V4L2_H264_DECODE_PARAM_FLAG_{}.
 */
export const v4l2_ctrl_h264_decode_params = StructType({
	dpb: new ArrayType(v4l2_h264_dpb_entry, V4L2_H264_NUM_DPB_ENTRIES),
	nal_ref_idc: ref.types.uint16,
	frame_num: ref.types.uint16,
	top_field_order_cnt: ref.types.int32,
	bottom_field_order_cnt: ref.types.int32,
	idr_pic_id: ref.types.uint16,
	pic_order_cnt_lsb: ref.types.uint16,
	delta_pic_order_cnt_bottom: ref.types.int32,
	delta_pic_order_cnt0: ref.types.int32,
	delta_pic_order_cnt1: ref.types.int32,
	dec_ref_pic_marking_bit_size: ref.types.uint32,
	pic_order_cnt_bit_size: ref.types.uint32,
	slice_group_change_cycle: ref.types.uint32,
	reserved: ref.types.uint32,
	flags: ref.types.uint32,
});

/* Stateless FWHT control, used by the vicodec driver */

/* Current FWHT version */
export const V4L2_FWHT_VERSION = 3;

/* Set if this is an interlaced format */
export const V4L2_FWHT_FL_IS_INTERLACED = _BITUL(0);
/* Set if this is a bottom-first (NTSC) interlaced format */
export const V4L2_FWHT_FL_IS_BOTTOM_FIRST = _BITUL(1);
/* Set if each 'frame' contains just one field */
export const V4L2_FWHT_FL_IS_ALTERNATE = _BITUL(2);
/*
 * If V4L2_FWHT_FL_IS_ALTERNATE was set, then this is set if this
 * 'frame' is the bottom field, else it is the top field.
 */
export const V4L2_FWHT_FL_IS_BOTTOM_FIELD = _BITUL(3);
/* Set if the Y' plane is uncompressed */
export const V4L2_FWHT_FL_LUMA_IS_UNCOMPRESSED = _BITUL(4);
/* Set if the Cb plane is uncompressed */
export const V4L2_FWHT_FL_CB_IS_UNCOMPRESSED = _BITUL(5);
/* Set if the Cr plane is uncompressed */
export const V4L2_FWHT_FL_CR_IS_UNCOMPRESSED = _BITUL(6);
/* Set if the chroma plane is full height, if cleared it is half height */
export const V4L2_FWHT_FL_CHROMA_FULL_HEIGHT = _BITUL(7);
/* Set if the chroma plane is full width, if cleared it is half width */
export const V4L2_FWHT_FL_CHROMA_FULL_WIDTH = _BITUL(8);
/* Set if the alpha plane is uncompressed */
export const V4L2_FWHT_FL_ALPHA_IS_UNCOMPRESSED = _BITUL(9);
/* Set if this is an I Frame */
export const V4L2_FWHT_FL_I_FRAME = _BITUL(10);

/* A 4-values flag - the number of components - 1 */
export const V4L2_FWHT_FL_COMPONENTS_NUM_MSK = 0x70000; // GENMASK(18, 16);
export const V4L2_FWHT_FL_COMPONENTS_NUM_OFFSET = 16;

/* A 4-values flag - the pixel encoding type */
export const V4L2_FWHT_FL_PIXENC_MSK = 0x180000; // GENMASK(20, 19);
export const V4L2_FWHT_FL_PIXENC_OFFSET = 19;
export const V4L2_FWHT_FL_PIXENC_YUV = (1 << V4L2_FWHT_FL_PIXENC_OFFSET);
export const V4L2_FWHT_FL_PIXENC_RGB = (2 << V4L2_FWHT_FL_PIXENC_OFFSET);
export const V4L2_FWHT_FL_PIXENC_HSV = (3 << V4L2_FWHT_FL_PIXENC_OFFSET);

export const V4L2_CID_STATELESS_FWHT_PARAMS = (V4L2_CID_CODEC_STATELESS_BASE + 100);
/**
 * struct v4l2_ctrl_fwht_params - FWHT parameters
 *
 * @backward_ref_ts: timestamp of the V4L2 capture buffer to use as reference.
 * The timestamp refers to the timestamp field in struct v4l2_buffer.
 * Use v4l2_timeval_to_ns() to convert the struct timeval to a __u64.
 * @version: must be V4L2_FWHT_VERSION.
 * @width: width of frame.
 * @height: height of frame.
 * @flags: FWHT flags (see V4L2_FWHT_FL_*).
 * @colorspace: the colorspace (enum v4l2_colorspace).
 * @xfer_func: the transfer function (enum v4l2_xfer_func).
 * @ycbcr_enc: the Y'CbCr encoding (enum v4l2_ycbcr_encoding).
 * @quantization: the quantization (enum v4l2_quantization).
 */
export const v4l2_ctrl_fwht_params = StructType({
	backward_ref_ts: ref.types.uint64,
	version: ref.types.uint32,
	width: ref.types.uint32,
	height: ref.types.uint32,
	flags: ref.types.uint32,
	colorspace: ref.types.uint32,
	xfer_func: ref.types.uint32,
	ycbcr_enc: ref.types.uint32,
	quantization: ref.types.uint32,
});

/* Stateless VP8 control */

export const V4L2_VP8_SEGMENT_FLAG_ENABLED = 0x01;
export const V4L2_VP8_SEGMENT_FLAG_UPDATE_MAP = 0x02;
export const V4L2_VP8_SEGMENT_FLAG_UPDATE_FEATURE_DATA = 0x04;
export const V4L2_VP8_SEGMENT_FLAG_DELTA_VALUE_MODE = 0x08;

/**
 * struct v4l2_vp8_segment - VP8 segment-based adjustments parameters
 *
 * @quant_update: update values for the segment quantizer.
 * @lf_update: update values for the loop filter level.
 * @segment_probs: branch probabilities of the segment_id decoding tree.
 * @padding: padding field. Should be zeroed by applications.
 * @flags: see V4L2_VP8_SEGMENT_FLAG_{}.
 *
 * This structure contains segment-based adjustments related parameters.
 * See the 'update_segmentation()' part of the frame header syntax,
 * and section '9.3. Segment-Based Adjustments' of the VP8 specification
 * for more details.
 */
export const v4l2_vp8_segment = StructType({
	quant_update: new ArrayType(ref.types.int8, 4),
	lf_update: new ArrayType(ref.types.int8, 4),
	segment_probs: new ArrayType(ref.types.uint8, 3),
	padding: ref.types.uint8,
	flags: ref.types.uint32,
});

export const V4L2_VP8_LF_ADJ_ENABLE = 0x01;
export const V4L2_VP8_LF_DELTA_UPDATE = 0x02;
export const V4L2_VP8_LF_FILTER_TYPE_SIMPLE = 0x04;

/**
 * struct v4l2_vp8_loop_filter - VP8 loop filter parameters
 *
 * @ref_frm_delta: Reference frame signed delta values.
 * @mb_mode_delta: MB prediction mode signed delta values.
 * @sharpness_level: matches sharpness_level syntax element.
 * @level: matches loop_filter_level syntax element.
 * @padding: padding field. Should be zeroed by applications.
 * @flags: see V4L2_VP8_LF_FLAG_{}.
 *
 * This structure contains loop filter related parameters.
 * See the 'mb_lf_adjustments()' part of the frame header syntax,
 * and section '9.4. Loop Filter Type and Levels' of the VP8 specification
 * for more details.
 */
export const v4l2_vp8_loop_filter = StructType({
	ref_frm_delta: new ArrayType(ref.types.int8, 4),
	mb_mode_delta: new ArrayType(ref.types.int8, 4),
	sharpness_level: ref.types.uint8,
	level: ref.types.uint8,
	padding: ref.types.uint16,
	flags: ref.types.uint32,
});

/**
 * struct v4l2_vp8_quantization - VP8 quantizattion indices
 *
 * @y_ac_qi: luma AC coefficient table index.
 * @y_dc_delta: luma DC delta vaue.
 * @y2_dc_delta: y2 block DC delta value.
 * @y2_ac_delta: y2 block AC delta value.
 * @uv_dc_delta: chroma DC delta value.
 * @uv_ac_delta: chroma AC delta value.
 * @padding: padding field. Should be zeroed by applications.
 *
 * This structure contains the quantization indices present
 * in 'quant_indices()' part of the frame header syntax.
 * See section '9.6. Dequantization Indices' of the VP8 specification
 * for more details.
 */
export const v4l2_vp8_quantization = StructType({
	y_ac_qi: ref.types.uint8,
	y_dc_delta: ref.types.int8,
	y2_dc_delta: ref.types.int8,
	y2_ac_delta: ref.types.int8,
	uv_dc_delta: ref.types.int8,
	uv_ac_delta: ref.types.int8,
	padding: ref.types.uint16,
});

export const V4L2_VP8_COEFF_PROB_CNT = 11;
export const V4L2_VP8_MV_PROB_CNT = 19;

/**
 * struct v4l2_vp8_entropy - VP8 update probabilities
 *
 * @coeff_probs: coefficient probability update values.
 * @y_mode_probs: luma intra-prediction probabilities.
 * @uv_mode_probs: chroma intra-prediction probabilities.
 * @mv_probs: mv decoding probability.
 * @padding: padding field. Should be zeroed by applications.
 *
 * This structure contains the update probabilities present in
 * 'token_prob_update()' and 'mv_prob_update()' part of the frame header.
 * See section '17.2. Probability Updates' of the VP8 specification
 * for more details.
 */
export const v4l2_vp8_entropy = StructType({
	coeff_probs: new ArrayType(new ArrayType(new ArrayType(new ArrayType(ref.types.uint8, V4L2_VP8_COEFF_PROB_CNT), 3), 8), 4),
	y_mode_probs: new ArrayType(ref.types.uint8, 4),
	uv_mode_probs: new ArrayType(ref.types.uint8, 3),
	mv_probs: new ArrayType(new ArrayType(ref.types.uint8, V4L2_VP8_MV_PROB_CNT), 2),
	padding: new ArrayType(ref.types.uint8, 3),
});

/**
 * struct v4l2_vp8_entropy_coder_state - VP8 boolean coder state
 *
 * @range: coder state value for "Range"
 * @value: coder state value for "Value"
 * @bit_count: number of bits left in range "Value".
 * @padding: padding field. Should be zeroed by applications.
 *
 * This structure contains the state for the boolean coder, as
 * explained in section '7. Boolean Entropy Decoder' of the VP8 specification.
 */

export const v4l2_vp8_entropy_coder_state = StructType({
	range: ref.types.uint8,
	value: ref.types.uint8,
	bit_count: ref.types.uint8,
	padding: ref.types.uint8,
});

export const V4L2_VP8_FRAME_FLAG_KEY_FRAME = 0x01;
export const V4L2_VP8_FRAME_FLAG_EXPERIMENTAL = 0x02;
export const V4L2_VP8_FRAME_FLAG_SHOW_FRAME = 0x04;
export const V4L2_VP8_FRAME_FLAG_MB_NO_SKIP_COEFF = 0x08;
export const V4L2_VP8_FRAME_FLAG_SIGN_BIAS_GOLDEN = 0x10;
export const V4L2_VP8_FRAME_FLAG_SIGN_BIAS_ALT = 0x20;

// #define V4L2_VP8_FRAME_IS_KEY_FRAME(hdr) \
// 	(!!((hdr)->flags & V4L2_VP8_FRAME_FLAG_KEY_FRAME))

export const V4L2_CID_STATELESS_VP8_FRAME = (V4L2_CID_CODEC_STATELESS_BASE + 200);
/**
 * struct v4l2_ctrl_vp8_frame - VP8 frame parameters
 *
 * @segment: segmentation parameters. See &v4l2_vp8_segment for more details
 * @lf: loop filter parameters. See &v4l2_vp8_loop_filter for more details
 * @quant: quantization parameters. See &v4l2_vp8_quantization for more details
 * @entropy: update probabilities. See &v4l2_vp8_entropy for more details
 * @coder_state: boolean coder state. See &v4l2_vp8_entropy_coder_state for more details
 * @width: frame width.
 * @height: frame height.
 * @horizontal_scale: horizontal scaling factor.
 * @vertical_scale: vertical scaling factor.
 * @version: bitstream version.
 * @prob_skip_false: frame header syntax element.
 * @prob_intra: frame header syntax element.
 * @prob_last: frame header syntax element.
 * @prob_gf: frame header syntax element.
 * @num_dct_parts: number of DCT coefficients partitions.
 * @first_part_size: size of the first partition, i.e. the control partition.
 * @first_part_header_bits: size in bits of the first partition header portion.
 * @dct_part_sizes: DCT coefficients sizes.
 * @last_frame_ts: "last" reference buffer timestamp.
 * The timestamp refers to the timestamp field in struct v4l2_buffer.
 * Use v4l2_timeval_to_ns() to convert the struct timeval to a __u64.
 * @golden_frame_ts: "golden" reference buffer timestamp.
 * @alt_frame_ts: "alt" reference buffer timestamp.
 * @flags: see V4L2_VP8_FRAME_FLAG_{}.
 */
export const v4l2_ctrl_vp8_frame = StructType({
	segment: v4l2_vp8_segment,
	lf: v4l2_vp8_loop_filter,
	quant: v4l2_vp8_quantization,
	entropy: v4l2_vp8_entropy,
	coder_state: v4l2_vp8_entropy_coder_state,
  
	width: ref.types.uint16,
	height: ref.types.uint16,
  
	horizontal_scale: ref.types.uint8,
	vertical_scale: ref.types.uint8,
  
	version: ref.types.uint8,
	prob_skip_false: ref.types.uint8,
	prob_intra: ref.types.uint8,
	prob_last: ref.types.uint8,
	prob_gf: ref.types.uint8,
	num_dct_parts: ref.types.uint8,
  
	first_part_size: ref.types.uint32,
	first_part_header_bits: ref.types.uint32,
	dct_part_sizes: new ArrayType(ref.types.uint32, 8),
  
	last_frame_ts: ref.types.uint64,
	golden_frame_ts: ref.types.uint64,
	alt_frame_ts: ref.types.uint64,
  
	flags: ref.types.uint64,
});

/* Stateless MPEG-2 controls */

export const V4L2_MPEG2_SEQ_FLAG_PROGRESSIVE = 0x01;

export const V4L2_CID_STATELESS_MPEG2_SEQUENCE = (V4L2_CID_CODEC_STATELESS_BASE+220);
/**
 * struct v4l2_ctrl_mpeg2_sequence - MPEG-2 sequence header
 *
 * All the members on this structure match the sequence header and sequence
 * extension syntaxes as specified by the MPEG-2 specification.
 *
 * Fields horizontal_size, vertical_size and vbv_buffer_size are a
 * combination of respective _value and extension syntax elements,
 * as described in section 6.3.3 "Sequence header".
 *
 * @horizontal_size: combination of elements horizontal_size_value and
 * horizontal_size_extension.
 * @vertical_size: combination of elements vertical_size_value and
 * vertical_size_extension.
 * @vbv_buffer_size: combination of elements vbv_buffer_size_value and
 * vbv_buffer_size_extension.
 * @profile_and_level_indication: see MPEG-2 specification.
 * @chroma_format: see MPEG-2 specification.
 * @flags: see V4L2_MPEG2_SEQ_FLAG_{}.
 */
export const v4l2_ctrl_mpeg2_sequence = StructType({
	horizontal_size: ref.types.uint16,
	vertical_size: ref.types.uint16,
	vbv_buffer_size: ref.types.uint32,
	profile_and_level_indication: ref.types.uint16,
	chroma_format: ref.types.uint8,
	flags: ref.types.uint8,
});

export const V4L2_MPEG2_PIC_CODING_TYPE_I = 1;
export const V4L2_MPEG2_PIC_CODING_TYPE_P = 2;
export const V4L2_MPEG2_PIC_CODING_TYPE_B = 3;
export const V4L2_MPEG2_PIC_CODING_TYPE_D = 4;

export const V4L2_MPEG2_PIC_TOP_FIELD = 0x1;
export const V4L2_MPEG2_PIC_BOTTOM_FIELD = 0x2;
export const V4L2_MPEG2_PIC_FRAME = 0x3;

export const V4L2_MPEG2_PIC_FLAG_TOP_FIELD_FIRST = 0x0001;
export const V4L2_MPEG2_PIC_FLAG_FRAME_PRED_DCT = 0x0002;
export const V4L2_MPEG2_PIC_FLAG_CONCEALMENT_MV = 0x0004;
export const V4L2_MPEG2_PIC_FLAG_Q_SCALE_TYPE = 0x0008;
export const V4L2_MPEG2_PIC_FLAG_INTRA_VLC = 0x0010;
export const V4L2_MPEG2_PIC_FLAG_ALT_SCAN = 0x0020;
export const V4L2_MPEG2_PIC_FLAG_REPEAT_FIRST = 0x0040;
export const V4L2_MPEG2_PIC_FLAG_PROGRESSIVE = 0x0080;

export const V4L2_CID_STATELESS_MPEG2_PICTURE = (V4L2_CID_CODEC_STATELESS_BASE+221);
/**
 * struct v4l2_ctrl_mpeg2_picture - MPEG-2 picture header
 *
 * All the members on this structure match the picture header and picture
 * coding extension syntaxes as specified by the MPEG-2 specification.
 *
 * @backward_ref_ts: timestamp of the V4L2 capture buffer to use as
 * reference for backward prediction.
 * @forward_ref_ts: timestamp of the V4L2 capture buffer to use as
 * reference for forward prediction. These timestamp refers to the
 * timestamp field in struct v4l2_buffer. Use v4l2_timeval_to_ns()
 * to convert the struct timeval to a __u64.
 * @flags: see V4L2_MPEG2_PIC_FLAG_{}.
 * @f_code: see MPEG-2 specification.
 * @picture_coding_type: see MPEG-2 specification.
 * @picture_structure: see V4L2_MPEG2_PIC_{}_FIELD.
 * @intra_dc_precision: see MPEG-2 specification.
 * @reserved: padding field. Should be zeroed by applications.
 */
export const v4l2_ctrl_mpeg2_picture = StructType({
	backward_ref_ts: ref.types.uint64,
	forward_ref_ts: ref.types.uint64,
	flags: ref.types.uint32,
	f_code: new ArrayType(new ArrayType(ref.types.uint8, 2), 2),
	picture_coding_type: ref.types.uint8,
	picture_structure: ref.types.uint8,
	intra_dc_precision: ref.types.uint8,
	reserved: new ArrayType(ref.types.uint8, 5),
});

export const V4L2_CID_STATELESS_MPEG2_QUANTISATION = (V4L2_CID_CODEC_STATELESS_BASE+222);
/**
 * struct v4l2_ctrl_mpeg2_quantisation - MPEG-2 quantisation
 *
 * Quantisation matrices as specified by section 6.3.7
 * "Quant matrix extension".
 *
 * @intra_quantiser_matrix: The quantisation matrix coefficients
 * for intra-coded frames, in zigzag scanning order. It is relevant
 * for both luma and chroma components, although it can be superseded
 * by the chroma-specific matrix for non-4:2:0 YUV formats.
 * @non_intra_quantiser_matrix: The quantisation matrix coefficients
 * for non-intra-coded frames, in zigzag scanning order. It is relevant
 * for both luma and chroma components, although it can be superseded
 * by the chroma-specific matrix for non-4:2:0 YUV formats.
 * @chroma_intra_quantiser_matrix: The quantisation matrix coefficients
 * for the chominance component of intra-coded frames, in zigzag scanning
 * order. Only relevant for 4:2:2 and 4:4:4 YUV formats.
 * @chroma_non_intra_quantiser_matrix: The quantisation matrix coefficients
 * for the chrominance component of non-intra-coded frames, in zigzag scanning
 * order. Only relevant for 4:2:2 and 4:4:4 YUV formats.
 */
export const v4l2_ctrl_mpeg2_quantisation = StructType({
	intra_quantiser_matrix: new ArrayType(ref.types.uint8, 64),
	non_intra_quantiser_matrix: new ArrayType(ref.types.uint8, 64),
	chroma_intra_quantiser_matrix: new ArrayType(ref.types.uint8, 64),
	chroma_non_intra_quantiser_matrix: new ArrayType(ref.types.uint8, 64),
});

export const V4L2_CID_COLORIMETRY_CLASS_BASE = (V4L2_CTRL_CLASS_COLORIMETRY | 0x900);
export const V4L2_CID_COLORIMETRY_CLASS = (V4L2_CTRL_CLASS_COLORIMETRY | 1);

export const V4L2_CID_COLORIMETRY_HDR10_CLL_INFO = (V4L2_CID_COLORIMETRY_CLASS_BASE + 0);

export const v4l2_ctrl_hdr10_cll_info = StructType({
	max_content_light_level: ref.types.uint16,
	max_pic_average_light_level: ref.types.uint16,
});

export const V4L2_CID_COLORIMETRY_HDR10_MASTERING_DISPLAY = (V4L2_CID_COLORIMETRY_CLASS_BASE + 1);

export const V4L2_HDR10_MASTERING_PRIMARIES_X_LOW = 5;
export const V4L2_HDR10_MASTERING_PRIMARIES_X_HIGH = 37000;
export const V4L2_HDR10_MASTERING_PRIMARIES_Y_LOW = 5;
export const V4L2_HDR10_MASTERING_PRIMARIES_Y_HIGH = 42000;
export const V4L2_HDR10_MASTERING_WHITE_POINT_X_LOW = 5;
export const V4L2_HDR10_MASTERING_WHITE_POINT_X_HIGH = 37000;
export const V4L2_HDR10_MASTERING_WHITE_POINT_Y_LOW = 5;
export const V4L2_HDR10_MASTERING_WHITE_POINT_Y_HIGH = 42000;
export const V4L2_HDR10_MASTERING_MAX_LUMA_LOW = 50000;
export const V4L2_HDR10_MASTERING_MAX_LUMA_HIGH = 100000000;
export const V4L2_HDR10_MASTERING_MIN_LUMA_LOW = 1;
export const V4L2_HDR10_MASTERING_MIN_LUMA_HIGH = 50000;

export const v4l2_ctrl_hdr10_mastering_display = StructType({
	display_primaries_x: new ArrayType(ref.types.uint16, 3),
	display_primaries_y: new ArrayType(ref.types.uint16, 3),
	white_point_x: ref.types.uint16,
	white_point_y: ref.types.uint16,
	max_display_mastering_luminance: ref.types.uint32,
	min_display_mastering_luminance: ref.types.uint32,
});

/* MPEG-compression definitions kept for backwards compatibility */
export const V4L2_CTRL_CLASS_MPEG = V4L2_CTRL_CLASS_CODEC;
export const V4L2_CID_MPEG_CLASS = V4L2_CID_CODEC_CLASS;
export const V4L2_CID_MPEG_BASE = V4L2_CID_CODEC_BASE;
export const V4L2_CID_MPEG_CX2341X_BASE = V4L2_CID_CODEC_CX2341X_BASE;
export const V4L2_CID_MPEG_MFC51_BASE = V4L2_CID_CODEC_MFC51_BASE;